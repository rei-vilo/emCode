#
# emCode
# ----------------------------------
# Embedded computing with make
#
# Copyright Â© Rei Vilo, 2010-2024
# All rights reserved
#
# Created: 12 Jan 2024 release 14.3.0
#
# Last update: 20 Jan 2024 release 14.3.1
#

# Silicon Labs for Arduino
# ----------------------------------
#
ifeq ($(MAKEFILE_NAME),)

SILABS_INITIAL = $(ARDUINO_PACKAGES_PATH)/SiliconLabs

ifneq ($(wildcard $(SILABS_INITIAL)/hardware/silabs),)
    SILABS_APP = $(SILABS_INITIAL)
    SILABS_PATH = $(SILABS_APP)
    SILABS_BOARDS = $(SILABS_APP)/hardware/silabs/$(SILICONLABS_SILABS_RELEASE)/boards.txt
endif

ifneq ($(call PARSE_FILE,$(BOARD_TAG),name,$(SILABS_BOARDS)),)
MAKEFILE_NAME = SiliconLabs
RELEASE_CORE = $(SILICONLABS_SILABS_RELEASE)
READY_FOR_EMCODE_NEXT = 1

# # Release check
# # ----------------------------------
# #
# REQUIRED_SILABS_RELEASE = 1.9.8
# ifeq ($(shell if [[ '$(SILICONLABS_SILABS_RELEASE)' > '$(REQUIRED_SILABS_RELEASE)' ]] || [[ '$(SILICONLABS_SILABS_RELEASE)' = '$(REQUIRED_SILABS_RELEASE)' ]]; then echo 1 ; else echo 0 ; fi ),0)
# $(error RP2040 release $(REQUIRED_SILABS_RELEASE) or later required, release $(SILICONLABS_SILABS_RELEASE) installed)
# endif

BOARD_OPTION_TAGS_LIST = $(BOARD_TAG1) $(BOARD_TAG2) $(BOARD_TAG3) $(BOARD_TAG4) $(BOARD_TAG5) $(BOARD_TAG6) $(BOARD_TAG7) $(BOARD_TAG8) $(BOARD_TAG9) $(BOARD_TAG10) 
# SEARCH_FOR = $(strip $(foreach t,$(1),$(call PARSE_BOARD,$(t),$(2))))

# Arduino RP2040 specifics
# ----------------------------------
#
PLATFORM := Silicon Labs
BUILD_CORE := SiLabs
SUB_PLATFORM := SiLabs
# For an unknwon reason, calling PARSE_BOARD freezes 
VARIANT = $(call PARSE_BOARD,$(BOARD_TAG),build.variant)
# VARIANT := $(shell grep ^$(BOARD_TAG).build.variant= $(SILABS_BOARDS)  | cut -d = -f 2-)

PLATFORM_TAG = ARDUINO=$(RELEASE_ARDUINO) ARDUINO_SILABS='"$(SILICONLABS_SILABS_RELEASE)"' EMCODE='"$(RELEASE_NOW)"' $(filter __%__ ,$(GCC_PREPROCESSOR_DEFINITIONS)) 
APPLICATION_PATH := $(ARDUINO_PATH)
PLATFORM_VERSION := $(SILICONLABS_SILABS_RELEASE) for Arduino $(ARDUINO_IDE_RELEASE)

HARDWARE_PATH = $(SILABS_PATH)/hardware/silabs/$(SILICONLABS_SILABS_RELEASE)
TOOL_CHAIN_PATH = $(SILABS_PATH)/tools/gcc-arm-none-eabi/$(SILICONLABS_GCC_ARM_RELEASE)
OTHER_TOOLS_PATH = $(SILABS_PATH)/tools

# New GCC for ARM tool-suite
APP_TOOLS_PATH := $(TOOL_CHAIN_PATH)/bin

CORE_LIB_PATH := $(HARDWARE_PATH)/cores/silabs
APP_LIB_PATH := $(HARDWARE_PATH)/libraries
BOARDS_TXT := $(HARDWARE_PATH)/boards.txt
BUILD_BOARD = $(call PARSE_BOARD,$(BOARD_TAG),build.board)

# FIRST_O_IN_A = $$(find $(BUILDS_PATH) -name variant.cpp.o)

VARIANT = $(call PARSE_BOARD,$(BOARD_TAG),build.variant)
VARIANT_PATH = $(HARDWARE_PATH)/variants/$(VARIANT)
VARIANT_CPP_SRCS = $(shell find $(VARIANT_PATH) -name \*.cpp)
VARIANT_C_SRCS = $(shell find $(VARIANT_PATH) -name \*.c)
VARIANT_AS1_SRCS = $(shell find $(VARIANT_PATH) -name \*.S)
# VARIANT_CPP_SRCS = $(wildcard $(VARIANT_PATH)/*.cpp) # $(VARIANT_PATH)/*/*.cpp
# VARIANT_C_SRCS = $(wildcard $(VARIANT_PATH)/*.c) # $(VARIANT_PATH)/*/*.c
# VARIANT_AS1_SRCS = $(wildcard $(VARIANT_PATH)/*.S) # $(VARIANT_PATH)/*/*.S
VARIANT_OBJ_FILES = $(VARIANT_CPP_SRCS:.cpp=.cpp.o) $(VARIANT_C_SRCS:.c=.c.o) $(VARIANT_AS1_SRCS:.S=.S.o)
VARIANT_OBJS = $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(VARIANT_OBJ_FILES))

# $(info >>> VARIANT_PATH $(VARIANT_PATH))
# $(info >>> VARIANT_CPP_SRCS $(VARIANT_CPP_SRCS))
# $(info >>> VARIANT_C_SRCS $(VARIANT_C_SRCS))
# $(info >>> VARIANT_AS1_SRCS $(VARIANT_AS1_SRCS))
# $(info >>> VARIANT_OBJ_FILES $(VARIANT_OBJ_FILES))
# $(info >>> VARIANT_OBJS $(VARIANT_OBJS))

# Generate main.cpp
# ----------------------------------
#
ifneq ($(strip $(KEEP_MAIN)),true)
    $(shell echo "// " > ./main.cpp)
    $(shell echo "// main.cpp generated by emCode" >> ./main.cpp)
    $(shell echo "// from $(CORE_LIB_PATH)" >> ./main.cpp)
    $(shell echo "// at $$(date +'%d %b %Y %T')" >> ./main.cpp)
    $(shell echo "// ----------------------------------" >> ./main.cpp)
    $(shell echo "// DO NOT EDIT THIS FILE." >> ./main.cpp)
    $(shell echo "// ----------------------------------" >> ./main.cpp)
    $(shell echo "#if defined(EMCODE)" >> ./main.cpp)
    $(shell echo " " >> ./main.cpp)
    $(shell cat $(CORE_LIB_PATH)/main.cpp >> ./main.cpp)
    $(shell echo " " >> ./main.cpp)
    $(shell echo "#include \"$(PROJECT_NAME_AS_IDENTIFIER).$(SKETCH_EXTENSION)\"" >> ./main.cpp)
    $(shell echo " " >> ./main.cpp)
    $(shell echo "#endif // EMCODE" >> ./main.cpp)
endif # KEEP_MAIN

# Uploader 
# UPLOADER defined in .mk
#
# TARGET_BIN_CP = $(BUILDS_PATH)/firmware.uf2
# COMMAND_UF2 = $(OTHER_TOOLS_PATH)/pqt-elf2uf2/$(SILABS_TOOLS_RELEASE)/elf2uf2 $(TARGET_ELF) $(TARGET_BIN_CP)
# 
# ifeq ($(UPLOADER),cp_uf2)
#     USB_RESET = stty -F 
#     TARGET_BIN_CP = $(BUILDS_PATH)/firmware.uf2
#     COMMAND_PREPARE = $(OTHER_TOOLS_PATH)/pqt-elf2uf2/$(SILABS_TOOLS_RELEASE)/elf2uf2 $(TARGET_ELF) $(TARGET_BIN_CP)
#     # USED_VOLUME_PORT = $(shell ls -d $(BOARD_VOLUME))
#     USED_VOLUME_PORT = $(strip $(BOARD_VOLUME))
# 
#     # Seeed Xiao does not support plain cp, while Raspberry Pi Pico does.
#     # Option 1 --- With https://github.com/microsoft/uf2
#     # stty -F $(AVRDUDE_PORT) 1200
#     # python uf2conv.py --family RP2040 --convert $(TARGET_ELF) --output $(TARGET_BIN_CP)
#     # python uf2conv.py --device $(AVRDUDE_PORT) --family RP2040 --deploy $(TARGET_BIN_CP)
#     # 
#     # Option 2 --- With .../Arduino15/packages/SiliconLabs/hardware/silabs/3.2.1/tools
#     # stty -F $(AVRDUDE_PORT) 1200
#     # python uf2conv.py --family RP2040 --convert $(TARGET_ELF) --output $(TARGET_BIN_CP)
#     # python uf2conv.py --device $(AVRDUDE_PORT) --family RP2040 --deploy $(TARGET_BIN_CP)
#     # End of options ---
#     UPLOADER_PATH = $(HARDWARE_PATH)/tools
#     UPLOADER_EXEC = $(UPLOADER_PATH)/uf2conv.py
#     UPLOADER_OPTS = --family RP2040 --deploy $(TARGET_BIN_CP)
#     # UPLOADER_OPTS += --device $(AVRDUDE_PORT) # Not required
#     COMMAND_UPLOAD = python $(UPLOADER_EXEC) $(UPLOADER_OPTS) 
# 
# else ifeq ($(UPLOADER),dfu-util)
# 
#     UPLOADER = dfu-util
#     USB_RESET = python $(UTILITIES_PATH)/reset_1200.py
#     UPLOADER_PATH = $(OTHER_TOOLS_PATH)/dfu-util/bin
#     UPLOADER_EXEC = $(UPLOADER_PATH)/dfu-util
#     UPLOADER_OPTS = $(UPLOADER_PATH)
#     UPLOADER_OPTS += --device $(call PARSE_BOARD,$(BOARD_TAG),upload.vid):$(call PARSE_BOARD,$(BOARD_TAG),upload.pid)
#     UPLOADER_OPTS += -a$(call PARSE_BOARD,$(BOARD_TAG),upload.interface)
#     UPLOADER_OPTS += -dfuse-address=$(call PARSE_BOARD,$(BOARD_TAG),upload.address):leave
#     COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) -D $(TARGET_BIN)
# 
# else ifeq ($(UPLOADER),picoprobe)
#     UPLOADER = openocd
# 
#     UPLOADER_PATH := $(EMCODE_TOOLS)/OpenOCD_RP2040/$(SILABS_OPENOCD_PICOPROBE_RELEASE)
#     UPLOADER_EXEC = $(UPLOADER_PATH)/openocd_picoprobe
#     UPLOADER_OPTS += -s $(UPLOADER_PATH)/tcl/
#     UPLOADER_OPTS += -f interface/picoprobe.cfg -f target/rp2040.cfg
#     UPLOADER_COMMAND = verify reset exit
#     COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) -c "program $(TARGET_HEX) $(UPLOADER_COMMAND)"
# 
# else ifeq ($(UPLOADER),debugprobe)
#     UPLOADER = openocd
# 
#     UPLOADER_PATH := $(OTHER_TOOLS_PATH)/pqt-openocd/$(SILABS_TOOLS_RELEASE)/bin
#     UPLOADER_EXEC = $(UPLOADER_PATH)/openocd
#     # /home/reivilo/.arduino15/packages/SiliconLabs/tools/pqt-openocd/1.5.0-b-c7bab52/share/openocd/scripts
#     UPLOADER_OPTS += -s $(OTHER_TOOLS_PATH)/pqt-openocd/$(SILABS_TOOLS_RELEASE)/share/openocd/scripts
# 
#     UPLOADER_OPTS += -f interface/cmsis-dap.cfg -f target/rp2040.cfg
#     UPLOADER_OPTS += -c "adapter speed 5000"
#     UPLOADER_COMMAND = verify reset exit
#     COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) -c "program $(TARGET_ELF) $(UPLOADER_COMMAND)"
# 
# else ifeq ($(UPLOADER),jlink)
#     UPLOADER = jlink
# 
#     # Prepare the .jlink scripts
#     COMMAND_PREPARE = printf 'r\nloadfile "$(BUILDS_PATH)/$(BINARY_SPECIFIC_NAME).hex"\ng\nexit\n' > '$(BUILDS_PATH)/upload.jlink' ;
#     COMMAND_PREPARE += printf "power on\nexit\n" > '$(BUILDS_PATH)/power.jlink' ;
# 
# 
#     UPLOADER_PATH := /usr/bin
#     UPLOADER_EXEC = $(UPLOADER_PATH)/JLinkExe
# 
#     UPLOADER_OPTS += -device SILABS_M0_0 -if swd -speed 2000 
#     COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) -commanderscript $(BUILDS_PATH)/upload.jlink
# 
# else
# 
#     UPLOADER = openocd
#     # UPLOADER_PATH := /usr/local
#     UPLOADER_PATH := $(OTHER_TOOLS_PATH)/pqt-openocd/$(SILABS_TOOLS_RELEASE)/bin
#     UPLOADER_EXEC = $(UPLOADER_PATH)/bin/openocd
#     UPLOADER_OPTS = $(call PARSE_BOARD,$(BOARD_TAG),upload.transport)
#     UPLOADER_OPTS += -s $(UPLOADER_PATH)/share/openocd/scripts/
#     UPLOADER_OPTS += -f interface/jlink.cfg -c 'transport select swd' -c 'adapter speed 2000' -f target/rp2040.cfg
#     UPLOADER_COMMAND = verify reset exit
#     COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) -c "program $(TARGET_HEX) $(UPLOADER_COMMAND)"
# 
#     JLINK_POWER ?= 0
#     ifeq ($(JLINK_POWER),1)
#         # COMMAND_POWER = printf "power on\nexit\n" > '$(BUILDS_PATH)/power.jlink' ;
#         COMMAND_POWER = printf "power on\ng\nexit\n" > '$(BUILDS_PATH)/power.jlink' ;
#         COMMAND_POWER += JLinkExe -device SILABS_M0_0 -if swd -speed 2000 -commanderscript '$(BUILDS_PATH)/power.jlink'
#     endif # JLINK_POWER
# 
# endif # UPLOADER

# "/home/reivilo/.arduino15/packages/SiliconLabs/tools/simplicitycommander/1.14.5/commander"  flash /home/reivilo/.var/app/cc.arduino.IDE2/cache/arduino/sketches/787161434EF5B388F6727A50919C6517/Blink.ino.elf
UPLOADER_PATH := $(OTHER_TOOLS_PATH)/simplicitycommander/$(SILICONLABS_TOOLS_RELEASE)
UPLOADER_EXEC = $(UPLOADER_PATH)/commander

UPLOADER_OPTS =  
COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) flash $(TARGET_ELF)

#  Boot-loader
# "/home/reivilo/.arduino15/packages/SiliconLabs/tools/simplicitycommander/1.14.5/commander"  flash /home/reivilo/.arduino15/packages/SiliconLabs/hardware/silabs/1.0.0/bootloaders/bgm220-explorer-kit-ble-bootloader-apploader.hex

# Tool-chain names
#
CC = $(APP_TOOLS_PATH)/arm-none-eabi-gcc
CXX = $(APP_TOOLS_PATH)/arm-none-eabi-g++
AR = $(APP_TOOLS_PATH)/arm-none-eabi-ar
OBJDUMP = $(APP_TOOLS_PATH)/arm-none-eabi-objdump
OBJCOPY = $(APP_TOOLS_PATH)/arm-none-eabi-objcopy
SIZE = $(APP_TOOLS_PATH)/arm-none-eabi-size
NM = $(APP_TOOLS_PATH)/arm-none-eabi-nm
GDB = $(APP_TOOLS_PATH)/arm-none-eabi-gdb

# Specific options
#
BOARD = $(call PARSE_BOARD,$(BOARD_TAG),board)

SYSTEM_LIB = $(call PARSE_BOARD,$(BOARD_TAG),build.variant_system_lib)
SYSTEM_PATH = $(VARIANT_PATH)
SYSTEM_OBJS = $(SYSTEM_PATH)/$(SYSTEM_LIB)

# Two locations for application libraries
# No, only HARDWARE_PATH as it contains all the libraries
#
APP_LIB_PATH = $(HARDWARE_PATH)/libraries

SILABS_00 = $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%,$(APP_LIBS_LIST)))
SILABS_00 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/utility,$(APP_LIBS_LIST)))
SILABS_00 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src,$(APP_LIBS_LIST)))
SILABS_00 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src/utility,$(APP_LIBS_LIST)))
SILABS_00 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src/arch/$(BUILD_CORE),$(APP_LIBS_LIST)))
SILABS_00 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src/$(BUILD_CORE),$(APP_LIBS_LIST)))
SILABS_00 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src/dhcpserver,$(APP_LIBS_LIST)))

APP_LIB_CPP_SRC = $(foreach dir,$(SILABS_00),$(wildcard $(dir)/*.cpp))
APP_LIB_C_SRC = $(foreach dir,$(SILABS_00),$(wildcard $(dir)/*.c))
APP_LIB_H_SRC = $(foreach dir,$(SILABS_00),$(wildcard $(dir)/*.h))
APP_LIB_H_SRC += $(foreach dir,$(SILABS_00),$(wildcard $(dir)/*.hpp))

APP_LIB_OBJS = $(patsubst $(HARDWARE_PATH)/%.cpp,$(OBJDIR)/%.cpp.o,$(APP_LIB_CPP_SRC))
APP_LIB_OBJS += $(patsubst $(HARDWARE_PATH)/%.c,$(OBJDIR)/%.c.o,$(APP_LIB_C_SRC))

# $(info >>> APP_LIB_PATH $(APP_LIB_PATH))
# $(info >>> APP_LIBS_LIST $(APP_LIBS_LIST))
# $(info >>> APP_LIB_OBJS $(APP_LIB_OBJS))

# Now, APPLICATION_PATH contains generic libraries and is duplicated
# BUILD_APP_LIB_PATH = $(APPLICATION_PATH)/libraries
# 
# SILABS_10 = $(foreach dir,$(BUILD_APP_LIB_PATH),$(patsubst %,$(dir)/%,$(APP_LIBS_LIST)))
# SILABS_10 += $(foreach dir,$(BUILD_APP_LIB_PATH),$(patsubst %,$(dir)/%/utility,$(APP_LIBS_LIST)))
# SILABS_10 += $(foreach dir,$(BUILD_APP_LIB_PATH),$(patsubst %,$(dir)/%/src,$(APP_LIBS_LIST)))
# SILABS_10 += $(foreach dir,$(BUILD_APP_LIB_PATH),$(patsubst %,$(dir)/%/src/utility,$(APP_LIBS_LIST)))
# SILABS_10 += $(foreach dir,$(BUILD_APP_LIB_PATH),$(patsubst %,$(dir)/%/src/arch/$(BUILD_CORE),$(APP_LIBS_LIST)))
# SILABS_10 += $(foreach dir,$(BUILD_APP_LIB_PATH),$(patsubst %,$(dir)/%/src/$(BUILD_CORE),$(APP_LIBS_LIST)))
# 
# BUILD_APP_LIB_CPP_SRC = $(foreach dir,$(SILABS_10),$(wildcard $(dir)/*.cpp))
# BUILD_APP_LIB_C_SRC = $(foreach dir,$(SILABS_10),$(wildcard $(dir)/*.c))
# BUILD_APP_LIB_H_SRC = $(foreach dir,$(SILABS_10),$(wildcard $(dir)/*.h))
# BUILD_APP_LIB_H_SRC += $(foreach dir,$(SILABS_10),$(wildcard $(dir)/*.hpp))
# 
# BUILD_APP_LIB_OBJS = $(patsubst $(APPLICATION_PATH)/%.cpp,$(OBJDIR)/%.cpp.o,$(BUILD_APP_LIB_CPP_SRC))
# BUILD_APP_LIB_OBJS += $(patsubst $(APPLICATION_PATH)/%.c,$(OBJDIR)/%.c.o,$(BUILD_APP_LIB_C_SRC))

APP_LIBS_LOCK = 1

# One location for core libraries
#
CORE_C_SRCS = $(wildcard $(CORE_LIB_PATH)/*.c $(CORE_LIB_PATH)/*/*.c)

# # SILABS_20 = $(filter-out %main.cpp, $(wildcard $(CORE_LIB_PATH)/*.cpp $(CORE_LIB_PATH)/*/*.cpp $(CORE_LIB_PATH)/*/*/*.cpp $(CORE_LIB_PATH)/*/*/*/*.cpp))
SILABS_CPP = $(filter-out %main.cpp, $(shell find $(CORE_LIB_PATH) -name \*.cpp))
CORE_CPP_SRCS = $(filter-out %/$(EXCLUDE_LIST),$(SILABS_CPP))

CORE_AS1_SRCS = $(wildcard $(CORE_LIB_PATH)/*.S)
CORE_AS2_SRCS = $(wildcard $(CORE_LIB_PATH)/*.s)
CORE_AS1_SRCS_OBJ = $(patsubst %.S,%.S.o,$(filter %S, $(CORE_AS1_SRCS)))
CORE_AS2_SRCS_OBJ = $(patsubst %.s,%.s.o,$(filter %s, $(CORE_AS2_SRCS)))

CORE_OBJ_FILES += $(CORE_C_SRCS:.c=.c.o) $(CORE_CPP_SRCS:.cpp=.cpp.o) $(CORE_AS1_SRCS_OBJ) $(CORE_AS2_SRCS_OBJ)
# CORE_OBJS += $(patsubst $(CORE_LIB_PATH)/%,$(OBJDIR)/%,$(CORE_OBJ_FILES))
# CORE_OBJS += $(patsubst $(APPLICATION_PATH)/%,$(OBJDIR)/%,$(CORE_OBJ_FILES))
CORE_OBJS += $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(CORE_OBJ_FILES))

CORE_LIBS_LOCK = 1

# MCU options
#
MCU_FLAG_NAME = mcpu
MCU = $(call PARSE_BOARD,$(BOARD_TAG),build.mcu)
# === MCU cortex-m0plus rp2040
# MCU = cortex-m0plus
F_CPU = $(call SEARCH_FOR,$(BOARD_TAG),build.f_cpu)

# $(info === MCU $(MCU))

# Include list
SILABS_01a = $(call PARSE_BOARD,$(BOARD_TAG),gsdk_folder)
SILABS_02a = $(call PARSE_BOARD,$(BOARD_TAG),build.gsdk_path)
SILABS_02b = $(shell echo $(SILABS_02a) | sed 's:{build.variant.path}:$(VARIANT_PATH):g')
SILABS_02c = $(shell echo $(SILABS_02b) | sed 's:{gsdk_folder}:$(SILABS_01a):g')

SILABS_03a = $(call PARSE_BOARD,$(BOARD_TAG),build.include_list)
SILABS_03b = $(shell echo $(SILABS_03a) | sed 's:{build.variant.path}:$(VARIANT_PATH):g')
SILABS_03c = $(shell echo $(SILABS_03b) | sed 's:{build.gsdk_path}:$(SILABS_02c):g')

FLAGS_INCLUDE := $(SILABS_03c)
FLAGS_INCLUDE += -I$(CORE_LIB_PATH)
FLAGS_INCLUDE += -I$(VARIANT_PATH)
FLAGS_INCLUDE += $(addprefix -I, $(sort $(dir $(APP_LIB_H_SRC) $(BUILD_APP_LIB_H_SRC))))

# $(info >>> SILABS_01a $(SILABS_01a))
# $(info >>> SILABS_02a $(SILABS_02a))
# $(info >>> SILABS_02b $(SILABS_02b))
# $(info >>> SILABS_02c $(SILABS_02c))
# $(info >>> SILABS_03a $(SILABS_03a))
# $(info >>> SILABS_03b $(SILABS_03b))
# $(info >>> SILABS_03c $(SILABS_03c))

# Flags for gcc, g++ and linker
# ----------------------------------
#
# Extra flags
# 
FLAGS_MORE = $(call PARSE_BOARD,$(BOARD_TAG),build.board_specific_macros)

FLAGS_FLOAT = $(call PARSE_BOARD,$(BOARD_TAG),build.float_flags)

# Common FLAGS_ALL for gcc, g++, assembler and linker
# {compiler.optimization_flags} {compiler.define} {build.extra_flags} {compiler.silabs.flags}={build.include_list} {includes}
#
SILABS_04a = $(call PARSE_FILE,build,compiler.optimization_flags,$(HARDWARE_PATH)/platform.txt)

FLAGS_ALL = $(SILABS_04a)

FLAGS_D = -DF_CPU=$(F_CPU)
FLAGS_D += $(addprefix -D, $(PLATFORM_TAG))
FLAGS_D += -DARDUINO_$(call PARSE_BOARD,$(BOARD_TAG),build.board) -DARDUINO_ARCH_SILABS

FLAGS_ALL += $(FLAGS_D)
FLAGS_ALL += $(OPTIMISATION) $(FLAGS_WARNING) 

SILABS_05a = $(call PARSE_BOARD,$(BOARD_TAG),build.board_specific_macros)
FLAGS_MORE := $(SILABS_05a)

SILABS_06a = $(call PARSE_BOARD,$(BOARD_TAG),build.extra_flags)
# SILABS_06b = $(shell echo $(SILABS_06a) | sed 's:{build.board_specific_macros}:$(FLAGS_MORE):g')
SILABS_06b = $(patsubst {build.board_specific_macros},$(FLAGS_MORE),$(SILABS_06a))

FLAGS_ALL += $(SILABS_06b)

SILABS_07a = $(call PARSE_BOARD,$(BOARD_TAG),build.precompiled_libs)
SILABS_07b = $(shell echo $(SILABS_07a) | sed 's:{build.gsdk_path}:$(SILABS_02c):g')
SILABS_07c = $(shell echo $(SILABS_07b) | sed 's:{build.variant.path}:$(VARIANT_PATH):g')

SILABS_PRE_LIBS = $(SILABS_07c)

# FLAGS_ALL += $(SILABS_07b)
FLAGS_ALL += $(FLAGS_INCLUDE)

# $(info >>> PLATFORM_TAG $(PLATFORM_TAG))
# $(info >>> addprefix $(addprefix -D, $(PLATFORM_TAG)))
# $(info >>> FLAGS_MORE $(FLAGS_MORE))
# 
# $(info >>> SILABS_04a $(SILABS_04a))
# $(info >>> SILABS_05a $(SILABS_05a))
# $(info >>> SILABS_06b $(SILABS_06b))
# $(info >>> SILABS_07b $(SILABS_07b))
# $(info >>> FLAGS_D $(FLAGS_D))
# $(info >>> FLAGS_ALL $(FLAGS_ALL))

# $(error STOP)

# Specific FLAGS_C for gcc only
# gcc uses FLAGS_ALL and FLAGS_C
#
SILABS_10a = $(call PARSE_BOARD,$(BOARD_TAG),build.c_flags)
SILABS_10b = $(shell echo $(SILABS_10a) | sed 's:{build.mcu}:$(MCU):g')
SILABS_10c = $(shell echo $(SILABS_10b) | sed 's:{compiler.warning_flags}:$(FLAGS_WARNING):g')
SILABS_10d = $(shell echo $(SILABS_10c) | sed 's:{build.float_flags}:$(FLAGS_FLOAT):g')

FLAGS_C := $(SILABS_10d) 
FLAGS_C += -MMD
FLAGS_C += -MP
# FLAGS_C += -MF

# FLAGS_C += "$@.d"
# FLAGS_C += -iprefix$(HARDWARE_PATH)/
# FLAGS_C += @$(HARDWARE_PATH)/lib/platform_inc.txt
# FLAGS_C += $(addprefix -I, $(INCLUDE_PATH))

# $(info >>> SILABS_10a $(SILABS_10a))
# $(info >>> SILABS_10b $(SILABS_10b))
# $(info >>> SILABS_10c $(SILABS_10c))
# $(info >>> SILABS_10d $(SILABS_10d))
# $(info >>> FLAGS_C $(FLAGS_C))

# Specific FLAGS_CPP for g++ only
# g++ uses FLAGS_ALL and FLAGS_CPP
#
SILABS_20a = $(call PARSE_BOARD,$(BOARD_TAG),build.cpp_flags)
SILABS_20b = $(shell echo $(SILABS_20a) | sed 's:{build.mcu}:$(MCU):g')
SILABS_20c = $(shell echo $(SILABS_20b) | sed 's:{compiler.warning_flags}:$(FLAGS_WARNING):g')
SILABS_20d = $(shell echo $(SILABS_20c) | sed 's:{build.float_flags}:$(FLAGS_FLOAT):g')

FLAGS_CPP := $(SILABS_20d) 

# $(info >>> SILABS_20a $(SILABS_20a))
# $(info >>> SILABS_20b $(SILABS_20b))
# $(info >>> SILABS_20c $(SILABS_20c))
# $(info >>> SILABS_20d $(SILABS_20d))
# $(info >>> FLAGS_CPP $(FLAGS_CPP))

# Specific FLAGS_AS for gcc assembler only
# gcc assembler uses FLAGS_ALL and FLAGS_AS
#
SILABS_30a = $(call PARSE_BOARD,$(BOARD_TAG),build.s_flags)
SILABS_30b = $(shell echo $(SILABS_30a) | sed 's:{build.mcu}:$(MCU):g')
FLAGS_AS := $(SILABS_30b) 
FLAGS_AS += -x assembler-with-cpp

# $(info >>> SILABS_30a $(SILABS_30a))
# $(info >>> SILABS_30b $(SILABS_30b))
# $(info >>> FLAGS_AS $(FLAGS_AS))

# FLAGS_D = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.debug_level)
# FLAGS_D += $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.debug_port)

# Specific FLAGS_LD for linker only
# linker uses FLAGS_ALL and FLAGS_LD
#
SILABS_40a = $(call PARSE_BOARD,$(BOARD_TAG),build.ld_flags)
SILABS_40b = $(shell echo $(SILABS_40a) | sed 's:{build.mcu}:$(MCU):g')
SILABS_40c = $(shell echo $(SILABS_40b) | sed 's:{build.path}/{build.project_name}:$(BUILDS_PATH)/$(BINARY_SPECIFIC_NAME):g')

FLAGS_LD := $(SILABS_40c) 
# FLAGS_LD = -u _printf_float -u _scanf_float

# Specific FLAGS_LIBS for linker only
#
FLAGS_LIBS = $(call PARSE_BOARD,$(BOARD_TAG),build.ld_libs)

# FLAGS_LD += $(SILABS_07c)

# $(info >>> SILABS_07c $(SILABS_07c))
# $(info >>> FLAGS_LD $(FLAGS_LD))
# $(error STOP)

# Specific FLAGS_OBJCOPY for objcopy only
# objcopy uses FLAGS_OBJCOPY only
#
FLAGS_OBJCOPY = -v -Obinary

# No USB PID VID
#
# USB_VID := $(call PARSE_BOARD,$(BOARD_TAG),vid.0)
# USB_PID := $(call PARSE_BOARD,$(BOARD_TAG),pid.0)
# USB_FLAGS_VID := $(call PARSE_BOARD,$(BOARD_TAG),build.usbvid)
# USB_FLAGS_PID := $(call PARSE_BOARD,$(BOARD_TAG),build.usbpid)
# USB_FLAGS_POWER = $(call PARSE_BOARD,$(BOARD_TAG),build.usbpwr)
# USB_PRODUCT := $(call PARSE_BOARD,$(BOARD_TAG),build.usb_product)
# USB_VENDOR := $(call PARSE_BOARD,$(BOARD_TAG),build.usb_manufacturer)
# 
# USB_VID = $(shell echo $(USB_FLAGS_VID) | cut -d= -f2)
# USB_PID = $(shell echo $(USB_FLAGS_PID) | cut -d= -f2)

# $(info >>> $(USB_VID) $(USB_PID))
# 
# ifeq ($(USB_VENDOR),)
#     USB_VENDOR = "Arduino"
# endif

# USB_FLAGS = -DCFG_TUSB_MCU=OPT_MCU_RP2040
# USB_FLAGS += -DUSB_VID=$(USB_VID)
# USB_FLAGS += -DUSB_PID=$(USB_PID)
# USB_FLAGS += -DUSB_MANUFACTURER='$(USB_VENDOR)'
# USB_FLAGS += -DUSB_PRODUCT='$(USB_PRODUCT)'
# USB_FLAGS += $(USB_FLAGS_PID) $(USB_FLAGS_VID) $(USB_FLAGS_POWER) $(USB_STACK)

# Serial 1200 reset
#
# USB_TOUCH := $(call PARSE_BOARD,$(BOARD_TAG),upload.protocol)
# USB_RESET = python $(UTILITIES_PATH)/reset_1200.py

ifeq ($(MAKECMDGOALS),debug)
    OPTIMISATION ?= -ggdb -g
else
    OPTIMISATION ?= -Os -g
endif # MAKECMDGOALS

INCLUDE_PATH = $(CORE_LIB_PATH) $(VARIANT_PATH)
INCLUDE_PATH += $(sort $(dir $(APP_LIB_CPP_SRC) $(APP_LIB_C_SRC) $(APP_LIB_H_SRC)))
INCLUDE_PATH += $(sort $(dir $(BUILD_APP_LIB_CPP_SRC) $(BUILD_APP_LIB_C_SRC) $(BUILD_APP_LIB_H_SRC)))

# rp2000a = $(call PARSE_BOARD,$(BOARD_TAG),build.extra_flags)
# FLAGS_MORE = $(filter-out {build.usb_flags}, $(rp2000a))
# FLAGS_MORE += $(call PARSE_BOARD,$(BOARD_TAG),build.float-abi)
# FLAGS_MORE += $(call PARSE_BOARD,$(BOARD_TAG),build.fpu)

TARGET_HEXBIN = $(TARGET_HEX)

# Commands
# ----------------------------------
# Link command
#
# FIRST_O_IN_LD = $$(find $(BUILDS_PATH) -name syscalls.c.o)
# FIRST_O_IN_LD = $(shell find . -name syscalls.c.o)

# recipe.c.combine.pattern="{compiler.path}{compiler.c.elf.cmd}" {} {} "-T{build.ldscript}" {compiler.ldflags} {object_files} -Wl,-whole-archive "{build.path}/{archive_file}" {compiler.silabs.precompiled_gsdk} -Wl,-no-whole-archive -Wl,--start-group {compiler.ldlibs} {compiler.silabs.precompiled_libs} -Wl,--end-group -o "{build.path}/{build.project_name}.elf"

SILABS_41a = $(call PARSE_BOARD,$(BOARD_TAG),build.precompiled_gsdk)
SILABS_41b = $(shell echo $(SILABS_41a) | sed 's:{build.variant.path}:$(VARIANT_PATH):g')

SILABS_PRE_GSDK = $(SILABS_41b)

# $(info >>> LOCAL_OBJS $(LOCAL_OBJS))
# $(info >>> LOCAL_ARCHIVES $(LOCAL_ARCHIVES))
# $(info >>> USER_ARCHIVES $(USER_ARCHIVES))
# $(info >>> OBJS_CORE $(OBJS_CORE))
# $(info >>> TARGET_A $(TARGET_A))

SILABS_42a = $(call PARSE_BOARD,$(BOARD_TAG),build.ldscript)
SILABS_42b = $(patsubst {build.variant.path}%,$(VARIANT_PATH)%,$(SILABS_42a))
LDSCRIPT = $(SILABS_42b)

# $(info >>> SILABS_41a $(SILABS_41a))
# $(info >>> SILABS_41b $(SILABS_41b))
# $(info >>> SILABS_42a $(SILABS_42a))
# $(info >>> SILABS_42b $(SILABS_42b))
# $(error STOP)

# recipe.c.combine.pattern="{compiler.path}{compiler.c.elf.cmd}" {compiler.c.elf.flags} {compiler.c.elf.extra_flags} "-T{build.ldscript}" {compiler.ldflags} {object_files} -Wl,-whole-archive "{build.path}/{archive_file}" {compiler.silabs.precompiled_gsdk} -Wl,-no-whole-archive -Wl,--start-group {compiler.ldlibs} {compiler.silabs.precompiled_libs} -Wl,--end-group -o "{build.path}/{build.project_name}.elf"
# TARGET_A repalced by OBJS_NON_CORE

COMMAND_LINK = $(CC) -T $(LDSCRIPT) $(FLAGS_LD) -Wl,--no-warn-rwx-segments $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(OBJS_NON_CORE) -Wl,-whole-archive -L$(OBJDIR) $(TARGET_CORE_A) $(SILABS_PRE_GSDK) -Wl,-no-whole-archive -Wl,--start-group $(FLAGS_LIBS) $(SILABS_PRE_LIBS) -Wl,--end-group $(OUT_PREPOSITION)$@

# Target
#
TARGET_HEXBIN = $(TARGET_HEX)
# TARGET_HEXBIN = $(TARGET_BIN)
# TARGET_EEP = $(OBJDIR)/$(BINARY_SPECIFIC_NAME).hex

endif # BOARD_TAG

endif # MAKEFILE_NAME

