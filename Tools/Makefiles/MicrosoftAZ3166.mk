#
# emCode
# ----------------------------------
# Embedded computing with make
#
# Copyright © Rei Vilo, 2010-2025
# All rights reserved
#
# Last update: 21 Jul 2020 release 11.9.4
# Deprecation notice: 04 Dec 2019 release 11.4.0
#

ifeq ($(MAKEFILE_NAME),)

MICROSOFT_AZ3166_INITIAL = $(ARDUINO_PACKAGES_PATH)/AZ3166

ifneq ($(wildcard $(MICROSOFT_AZ3166_INITIAL)/hardware/stm32f4),)
    MICROSOFT_AZ3166_APP = $(MICROSOFT_AZ3166_INITIAL)
    MICROSOFT_AZ3166_PATH = $(MICROSOFT_AZ3166_APP)
    MICROSOFT_AZ3166_BOARDS = $(MICROSOFT_AZ3166_INITIAL)/hardware/stm32f4/$(MICROSOFT_AZ3166_RELEASE)/boards.txt
endif

ifneq ($(call PARSE_FILE,$(BOARD_TAG),name,$(MICROSOFT_AZ3166_BOARDS)),)
MAKEFILE_NAME = MicrosoftAZ3166
READY_FOR_EMCODE_NEXT = 1

# MESSAGE_WARNING = BETA! Not yet tested against $(CONFIG_NAME).
SERIAL_BAUDRATE := 115200

# # Release check
# # ----------------------------------
# #
# REQUIRED_MICROSOFT_AZ3166_RELEASE = 2.0.0
# ifeq ($(shell if [[ '$(MICROSOFT_AZ3166_RELEASE)' > '$(REQUIRED_MICROSOFT_AZ3166_RELEASE)' ]] || [[ '$(MICROSOFT_AZ3166_RELEASE)' = '$(REQUIRED_MICROSOFT_AZ3166_RELEASE)' ]] ; then echo 1 ; else echo 0 ; fi ),0)
# $(error Microsoft Azure IoT release $(REQUIRED_MICROSOFT_AZ3166_RELEASE) or later is required, $(MICROSOFT_AZ3166_RELEASE) installed.)
# endif

# Microsoft AZ3166 specifics
# ----------------------------------
#
PLATFORM := Microsoft AZ3166
PLATFORM_TAG = ARDUINO=$(RELEASE_ARDUINO) EMCODE=$(RELEASE_NOW) ARDUINO_MXCHIP_AZ3166 ARDUINO_ARCH_STM32F4
APPLICATION_PATH := $(MICROSOFT_AZ3166_PATH)
PLATFORM_VERSION := Microsoft $(MICROSOFT_AZ3166_RELEASE) for Arduino $(ARDUINO_IDE_RELEASE)

HARDWARE_PATH = $(APPLICATION_PATH)/hardware/stm32f4/$(MICROSOFT_AZ3166_RELEASE)
TOOL_CHAIN_PATH = $(APPLICATION_PATH)/tools/arm-none-eabi-gcc/$(MICROSOFT_GCC_ARM_RELEASE)
OTHER_TOOLS_PATH = $(APPLICATION_PATH)/tools/openocd/$(MICROSOFT_OPENOCD_RELEASE)

BUILD_CORE = arduino
SUB_PLATFORM = arduino
BOARDS_TXT := $(HARDWARE_PATH)/boards.txt
BUILD_CORE = $(call PARSE_BOARD,$(BOARD_TAG),build.core)
SUB_PLATFORM = $(BUILD_CORE)

# Uploader
#
# ifeq ($(MAKECMDGOALS),debug)
#     UPLOADER = 0
#     DEBUG_SERVER_PATH = $(APPLICATION_PATH)/tools/openocd/$(MICROSOFT_OPENOCD_RELEASE)/macosx
#     DEBUG_SERVER_NAME = openocd
#     DEBUG_SERVER_EXEC = $(DEBUG_SERVER_PATH)/bin/$(DEBUG_SERVER_NAME)
#     DEBUG_SERVER_OPTS = -f $(DEBUG_SERVER_PATH)/scripts/interface/stlink-v2-1.cfg
#     DEBUG_SERVER_OPTS += -c \"transport select hla_swd\"
#     DEBUG_SERVER_OPTS += -f $(DEBUG_SERVER_PATH)/scripts/target/stm32f4x.cfg
#     COMMAND_DEBUG_SERVER = $(DEBUG_SERVER_EXEC) $(DEBUG_SERVER_OPTS)
#     COMMAND_UPLOAD = 0
# else
#     ifeq ($(UPLOADER),cp_bin)
#                 TARGET_BIN_CP = $(OBJDIR)/$(BINARY_SPECIFIC_NAME)_cp.bin
#         COMMAND_PRE_UPLOAD = dd conv=notrunc bs=1 if=$(HARDWARE_PATH)/bootloader/boot.bin of=$(TARGET_BIN_CP) seek=$$((0x0000)) ;
#         COMMAND_PRE_UPLOAD += dd conv=notrunc bs=1 if=$(TARGET_BIN) of=$(TARGET_BIN_CP) seek=$$((0xC000)) ;
#     else
        UPLOADER = openocd
#         UPLOADER_PATH = $(APPLICATION_PATH)/tools/openocd/$(MICROSOFT_OPENOCD_RELEASE)/macosx
        UPLOADER_PATH = /usr
        UPLOADER_EXEC = $(UPLOADER_PATH)/bin/openocd
        UPLOADER_OPTS = -f interface/stlink-v2-1.cfg
        UPLOADER_OPTS += -c "transport select hla_swd"
        UPLOADER_OPTS += -f target/stm32f4x.cfg
        UPLOADER_OPTS += -c "program {$(TARGET_BIN)} verify reset 0x800C000; shutdown"
        COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS)
#     endif # UPLOADER
# endif # MAKECMDGOALS

APP_TOOLS_PATH := $(TOOL_CHAIN_PATH)/bin
CORE_LIB_PATH := $(HARDWARE_PATH)/cores/arduino
APP_LIB_PATH := $(HARDWARE_PATH)/libraries

# Generate main.cpp
# ----------------------------------
#
ifneq ($(strip $(KEEP_MAIN)),true)
$(shell echo "// " > ./main.cpp)
$(shell echo "// main.cpp generated by emCode" >> ./main.cpp)
#$(shell echo "// from $(CORE_LIB_PATH)/system/main.cpp" >> ./main.cpp)
$(shell echo "// at $$(date +'%d %b %Y %T')" >> ./main.cpp)
$(shell echo "// ----------------------------------" >> ./main.cpp)
$(shell echo "// DO NOT EDIT THIS FILE." >> ./main.cpp)
$(shell echo "// ----------------------------------" >> ./main.cpp)
$(shell echo "#if defined(EMCODE)" >> ./main.cpp)
#$(shell echo " " >> ./main.cpp)
#$(shell cat $(CORE_LIB_PATH)/system/main.cpp >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo "#include \"$(PROJECT_NAME_AS_IDENTIFIER).$(SKETCH_EXTENSION)\"" >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo "#endif // EMCODE" >> ./main.cpp)
endif

# Core files
# Crazy maze of sub-folders
#
CORE_C_SRCS = $(shell find $(CORE_LIB_PATH) -name \*.c)
ms1300 = $(filter-out %main.cpp, $(shell find $(CORE_LIB_PATH) -name \*.cpp))
CORE_CPP_SRCS = $(filter-out %/$(EXCLUDE_LIST),$(ms1300))
CORE_AS1_SRCS = $(shell find $(CORE_LIB_PATH) -name \*.S)
CORE_AS1_SRCS_OBJ = $(patsubst %.S,%.S.o,$(filter %.S, $(CORE_AS1_SRCS)))
CORE_AS2_SRCS = $(shell find $(CORE_LIB_PATH) -name \*.s)
CORE_AS2_SRCS_OBJ = $(patsubst %.s,%.s.o,$(filter %.s, $(CORE_AS_SRCS)))

CORE_OBJ_FILES = $(CORE_C_SRCS:.c=.c.o) $(CORE_CPP_SRCS:.cpp=.cpp.o) $(CORE_AS1_SRCS_OBJ) $(CORE_AS2_SRCS_OBJ)
CORE_OBJS = $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(CORE_OBJ_FILES))

CORE_LIBS_LOCK = 1

# Application libraries
#
APP_LIB_PATH := $(HARDWARE_PATH)/libraries

ifneq ($(strip $(APP_LIBS_LIST)),0)
ms1000 = $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%,$(APP_LIBS_LIST)))
ms1000 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/utility,$(APP_LIBS_LIST)))
ms1000 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src,$(APP_LIBS_LIST)))
ms1000 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src/utility,$(APP_LIBS_LIST)))
ms1000 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src/arch/$(BUILD_CORE),$(APP_LIBS_LIST)))
ms1000 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(dir)/%/src/$(BUILD_CORE),$(APP_LIBS_LIST)))
ms1000 += $(foreach dir1,$(APP_LIB_PATH),$(foreach dir2,$(APP_LIBS_LIST),$(shell find $(dir1)/$(dir2)/src -type d))))

# ms1000 += $(foreach dir,$(APP_LIB_PATH),$(patsubst %,$(shell find $(dir)/%/src/$(BUILD_CORE) -type d),$(APP_LIBS_LIST)))

APP_LIB_CPP_SRC = $(foreach dir,$(ms1000),$(wildcard $(dir)/*.cpp))
APP_LIB_C_SRC = $(foreach dir,$(ms1000),$(wildcard $(dir)/*.c))
APP_LIB_S_SRC = $(foreach dir,$(ms1000),$(wildcard $(dir)/*.S))
APP_LIB_IPP_SRC = $(foreach dir,$(ms1000),$(wildcard $(dir)/*.ipp))
APP_LIB_H_SRC = $(foreach dir,$(ms1000),$(wildcard $(dir)/*.h))
APP_LIB_H_SRC += $(foreach dir,$(ms1000),$(wildcard $(dir)/*.hpp))

APP_LIB_OBJS = $(patsubst $(HARDWARE_PATH)/%.cpp,$(OBJDIR)/%.cpp.o,$(APP_LIB_CPP_SRC))
APP_LIB_OBJS += $(patsubst $(HARDWARE_PATH)/%.c,$(OBJDIR)/%.c.o,$(APP_LIB_C_SRC))

BUILD_APP_LIBS_LIST = $(subst $(BUILD_APP_LIB_PATH)/, ,$(APP_LIB_CPP_SRC))
endif

APP_LIBS_LOCK = 1

VARIANT = $(call PARSE_BOARD,$(BOARD_TAG),build.variant)
VARIANT_PATH = $(HARDWARE_PATH)/variants/$(VARIANT)
LDSCRIPT_PATH = $(VARIANT_PATH)
LDSCRIPT = $(VARIANT_PATH)/$(call PARSE_BOARD,$(BOARD_TAG),build.ldscript)

VARIANT_CPP_SRCS = $(wildcard $(VARIANT_PATH)/*.cpp)
VARIANT_OBJ_FILES = $(VARIANT_CPP_SRCS:.cpp=.cpp.o)
VARIANT_OBJS = $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(VARIANT_OBJ_FILES))

# Tool-chain names
#
CC = $(APP_TOOLS_PATH)/arm-none-eabi-gcc
CXX = $(APP_TOOLS_PATH)/arm-none-eabi-g++
AR = $(APP_TOOLS_PATH)/arm-none-eabi-ar
OBJDUMP = $(APP_TOOLS_PATH)/arm-none-eabi-objdump
OBJCOPY = $(APP_TOOLS_PATH)/arm-none-eabi-objcopy
SIZE = $(APP_TOOLS_PATH)/arm-none-eabi-size
NM = $(APP_TOOLS_PATH)/arm-none-eabi-nm
GDB = $(APP_TOOLS_PATH)/arm-none-eabi-gdb

MCU_FLAG_NAME = mcpu
MCU = $(call PARSE_BOARD,$(BOARD_TAG),build.mcu)
F_CPU = $(call PARSE_BOARD,$(BOARD_TAG),build.f_cpu)
OPTIMISATION ?= -O0 -g3
FLAGS_WARNING = -Wall -Wextra

# from platform.txt
azure1001 = $(call PARSE_FILE,compiler,libstm.c.flags,$(HARDWARE_PATH)/platform.txt)
azure1002 = $(shell echo $(azure1001) | sed 's:-I{build.core.path}:$(CORE_LIB_PATH):g')
INCLUDE_PATH += $(shell echo $(azure1002) | sed 's:-I{build.system.path}:$(HARDWARE_PATH)/system:g')

INCLUDE_PATH += $(CORE_LIB_PATH) $(APP_LIB_PATH) $(VARIANT_PATH) $(HARDWARE_PATH)
INCLUDE_PATH += $(sort $(dir $(APP_LIB_CPP_SRC) $(APP_LIB_C_SRC) $(APP_LIB_H_SRC) $(APP_LIB_IPP_SRC)))
INCLUDE_PATH += $(sort $(dir $(BUILD_APP_LIB_CPP_SRC) $(BUILD_APP_LIB_C_SRC) $(BUILD_APP_LIB_H_SRC) $(BUILD_APP_LIB_IPP_SRC)))
INCLUDE_PATH += $(OBJDIR)

# INCLUDE_PATH += $(sort $(shell find $(CORE_LIB_PATH) -type d))
# from platform.txt
# INCLUDE_PATH += $(shell find $(HARDWARE_PATH)/system -type d)
# INCLUDE_PATH += $(shell find $(HARDWARE_PATH)/cores -type d)

# from platform.txt
FLAGS_D = printf=iprintf
FLAGS_D += STM32_DEVICE STM32F2XX PLATFORM_THREADING=1 PLATFORM_ID=88 PLATFORM_NAME=duo
FLAGS_D += USBD_VID_SPARK=0x2B04 USBD_PID_DFU=0xD058 USBD_PID_CDC=0xC058
FLAGS_D += START_DFU_FLASHER_SERIAL_SPEED=14400 START_YMODEM_FLASHER_SERIAL_SPEED=28800
FLAGS_D += START_AVRDUDE_FLASHER_SERIAL_SPEED=19200 RELEASE_BUILD INCLUDE_PLATFORM=1
FLAGS_D += USE_STDPERIPH_DRIVER DFU_BUILD_ENABLE USER_FIRMWARE_IMAGE_SIZE=0x40000
FLAGS_D += USER_FIRMWARE_IMAGE_LOCATION=0x80C0000 SYSTEM_VERSION_STRING=0.2.4
FLAGS_D += MODULAR_FIRMWARE=1 MODULE_FUNCTION=5 MODULE_INDEX=1 MODULE_VERSION=7
FLAGS_D += MODULE_DEPENDENCY=4,2,7
FLAGS_D += MBED_BUILD_TIMESTAMP=$(shell date +%s)

# Flags for gcc, g++ and linker
# ----------------------------------
#
# Common FLAGS_ALL for gcc, g++, assembler and linker
#
FLAGS_ALL = $(OPTIMISATION) $(FLAGS_WARNING)  # -w
FLAGS_ALL += -$(MCU_FLAG_NAME)=$(MCU) # -DF_CPU=$(F_CPU)
FLAGS_ALL += $(addprefix -D, $(PLATFORM_TAG))

# from platform.txt
FLAGS_ALL += -ffunction-sections -fdata-sections -nostdlib
FLAGS_ALL += --param max-inline-insns-single=500 -D__MBED__=1
FLAGS_ALL += -DDEVICE_I2CSLAVE=1 # -DLWIP_TIMEVAL_PRIVATE=0
FLAGS_ALL += -DTARGET_LIKE_MBED -DDEVICE_PORTOUT=1 # -DUSBHOST_OTHER
FLAGS_ALL += -DDEVICE_PORTINOUT=1 -DTARGET_RTOS_M4_M7
FLAGS_ALL += -DDEVICE_LOWPOWERTIMER=1 -DDEVICE_RTC=1
FLAGS_ALL += -DTOOLCHAIN_object -DDEVICE_SERIAL_ASYNCH=1
FLAGS_ALL += -DTARGET_STM32F4 -D__CMSIS_RTOS # -DTARGET_EMW1062
FLAGS_ALL += -DTOOLCHAIN_GCC -DDEVICE_CAN=1 -DTARGET_CORTEX_M
FLAGS_ALL += -DTARGET_DEBUG -DDEVICE_I2C_ASYNCH=1
FLAGS_ALL += -DTARGET_LIKE_CORTEX_M4 -DTARGET_M4
FLAGS_ALL += -DTARGET_UVISOR_UNSUPPORTED -DDEVICE_QSPI=1
FLAGS_ALL += -DDEVICE_SPI_ASYNCH=1
FLAGS_ALL += -DMBED_BUILD_TIMESTAMP=$(shell date +%s)
FLAGS_ALL += -DDEVICE_PWMOUT=1 -DDEVICE_INTERRUPTIN=1 -DDEVICE_I2C=1
FLAGS_ALL += -DTRANSACTION_QUEUE_SIZE_SPI=2 -D__CORTEX_M4
FLAGS_ALL += -DDEVICE_STDIO_MESSAGES=1 -DHSE_VALUE=26000000L
FLAGS_ALL += -DTARGET_FF_MORPHO -D__FPU_PRESENT=1 -DTARGET_FF_ARDUINO
FLAGS_ALL += -DDEVICE_PORTIN=1 -DTARGET_STM -DDEVICE_SERIAL_FC=1
FLAGS_ALL += -DDEVICE_SDIO=1 -DDEVICE_TRNG=1 -D__MBED_CMSIS_RTOS_CM
FLAGS_ALL += -DDEVICE_SLEEP=1 -DTOOLCHAIN_GCC_ARM -DTARGET_MXCHIP
FLAGS_ALL += -DDEVICE_SPI=1 -DUSB_STM_HAL -DMXCHIP_LIBRARY
FLAGS_ALL += -DDEVICE_SPISLAVE=1 -DDEVICE_ANALOGIN=1 -DDEVICE_SERIAL=1
FLAGS_ALL += -DDEVICE_ERROR_RED=1 -DTARGET_AZ3166 -DARM_MATH_CM4
FLAGS_ALL += -DLPS22HB_I2C_PORT=MICO_I2C_1 # -DDONT_USE_UPLOADTOBLOB
# FLAGS_ALL += -DUSE_MBED_TLS -DUSE_MBED_TLS -DUSE_PROV_MODULE
# FLAGS_ALL += -DHSM_TYPE_X509 -DHSM_TYPE_SYMM_KEY
# FLAGS_ALL += -DMBED_HEAP_STATS_ENABLED=1 -DMBED_STACK_STATS_ENABLED=1
FLAGS_ALL += -include mbed_config.h -MMD
FLAGS_ALL += -mthumb -mfloat-abi=softfp -mfpu=fpv4-sp-d16

# Specific FLAGS_C for gcc only
# gcc uses FLAGS_ALL and FLAGS_C
#
FLAGS_C = -std=gnu99
FLAGS_C += $(addprefix -I, $(INCLUDE_PATH))

# Specific FLAGS_CPP for g++ only
# g++ uses FLAGS_ALL and FLAGS_CPP
#
FLAGS_CPP = -std=gnu++11
FLAGS_CPP += -Wall -Wextra -Wno-unused-parameter -Wno-missing-field-initializers
FLAGS_CPP += -fmessage-length=0 -fno-threadsafe-statics -fno-rtti -Wvla
FLAGS_CPP += $(addprefix -I, $(INCLUDE_PATH))

# Specific FLAGS_AS for gcc assembler only
# gcc assembler uses FLAGS_ALL and FLAGS_AS
#
FLAGS_AS = -x assembler-with-cpp

# Specific FLAGS_LD for linker only
# linker uses FLAGS_ALL and FLAGS_LD
#
FLAGS_LD = $(OPTIMISATION) $(FLAGS_WARNING)  # -w
FLAGS_LD += -$(MCU_FLAG_NAME)=$(MCU) # -DF_CPU=$(F_CPU)
FLAGS_LD += -mthumb # -fno-builtin -Werror
FLAGS_LD += -L$(BUILDS_PATH)
# FLAGS_LD += -L$(HARDWARE_PATH)/system/sdk/lib
# FLAGS_LD += -L$(HARDWARE_PATH)/system/emw10xx-driver/libwlan/TARGET_EMW1062
FLAGS_LD += -L$(HARDWARE_PATH)/system
FLAGS_LD += -L$(HARDWARE_PATH)/system/az3166-driver
FLAGS_LD += -L$(HARDWARE_PATH)/system/az3166-driver/libwlan/TARGET_EMW1062
FLAGS_LD += -T $(LDSCRIPT)

# FLAGS_LD += $(addprefix -I, $(INCLUDE_PATH))

FLAGS_LD += -Wl,--cref -Wl,--check-sections -Wl,--gc-sections
FLAGS_LD += -Wl,--unresolved-symbols=report-all -Wl,--warn-common -Wl,--warn-section-align
FLAGS_LD += -Wl,-Map,$(BUILDS_PATH)/$(BINARY_SPECIFIC_NAME).map # Output a cross reference table.
FLAGS_LD += -Wl,--gc-sections
FLAGS_LD += -Wl,--wrap,_malloc_r -Wl,--wrap,_free_r -Wl,--wrap,_realloc_r
FLAGS_LD += -Wl,--wrap,_calloc_r

LDFLAGS3 += -lwlan -lstsafe -ldevkit-sdk-core-lib -lm -lstdc++ -gcc
LDFLAGS3 += --specs=nano.specs --specs=nosys.specs -u _printf_float

# from platform.txt
# FIRST_OBJS = $(shell find $(HARDWARE_PATH)/system/emw10xx-driver -name \*.o)

# Specific FLAGS_OBJCOPY for objcopy only
# objcopy uses FLAGS_OBJCOPY only
#
FLAGS_OBJCOPY = -v -Obinary

# Target
#
TARGET_HEXBIN = $(TARGET_BIN)

# Commands
# ----------------------------------
# Link command
#
# COMMAND_LINK = $(CC) $(FLAGS_LD) -Wl,--start-group $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) -Wl,--end-group -o $(TARGET_ELF) $(FLAGS_LD_2) $(LDFLAGS3)
## COMMAND_LINK = $(CC) $(FLAGS_LD) -o $(TARGET_ELF) -Wl,--start-group $(FIRST_OBJS) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) -ldevkit-sdk-core-lib $(TARGET_A) -Wl,--end-group $(FLAGS_LD_2) $(LDFLAGS3)
COMMAND_LINK = $(CC) $(FLAGS_LD) -o $(TARGET_ELF) -Wl,--start-group $(FIRST_OBJS) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) -ldevkit-sdk-core-lib $(TARGET_A) $(TARGET_CORE_A) -Wl,--end-group $(FLAGS_LD_2) $(LDFLAGS3)

# Upload command
#
# COMMAND_UPLOAD = $(AVRDUDE_EXEC) $(AVRDUDE_COM_OPTS) $(AVRDUDE_OPTS) -P$(USED_SERIAL_PORT) -Uflash:w:$(TARGET_HEX):i

endif

endif # MAKEFILE_NAME

