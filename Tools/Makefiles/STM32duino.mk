#
# emCode
# ----------------------------------
# Embedded computing with make
#
# Copyright © Rei Vilo, 2010-2024
# All rights reserved
#
# Last update: 21 Jul 2024 release 14.4.8
#

ifeq ($(MAKEFILE_NAME),)

STM32DUINO_INITIAL = $(ARDUINO_PACKAGES_PATH)/STMicroelectronics

ifneq ($(wildcard $(STM32DUINO_INITIAL)/hardware/stm32),)
    STM32DUINO_APP = $(STM32DUINO_INITIAL)
    STM32DUINO_PATH = $(STM32DUINO_APP)
    STM32DUINO_BOARDS = $(STM32DUINO_APP)/hardware/stm32/$(STM32DUINO_RELEASE)/boards.txt
endif

BOARD_CHECK := 0
ifneq ($(filter STM32DUINO,$(GCC_PREPROCESSOR_DEFINITIONS)),)
ifneq ($(call PARSE_FILE,$(BOARD_TAG),name,$(STM32DUINO_BOARDS)),)
    BOARD_CHECK := 1
endif
endif

ifeq ($(BOARD_CHECK),1)
MAKEFILE_NAME = STM32duino
RELEASE_CORE = $(STM32DUINO_RELEASE)
READY_FOR_EMCODE_NEXT = 1

# Complicated menu system for Arduino 1.5
# Another example of Arduino's quick and dirty job
#
BOARD_TAGS_LIST = $(BOARD_TAG) $(BOARD_TAG1) $(BOARD_TAG2) $(BOARD_TAG3)
BOARD_OPTION_TAGS_LIST = $(BOARD_TAG1) $(BOARD_TAG2) $(BOARD_TAG3)

# SEARCH_FOR = $(strip $(foreach t,$(1),$(call PARSE_BOARD,$(t),$(2))))

# STM32duino specifics
# ----------------------------------
#
APPLICATION_PATH := $(STM32DUINO_PATH)
PLATFORM_VERSION := STM32duino $(STM32DUINO_RELEASE) for Arduino $(ARDUINO_IDE_RELEASE)

HARDWARE_PATH = $(APPLICATION_PATH)/hardware/stm32/$(STM32DUINO_RELEASE)
TOOL_CHAIN_PATH = $(APPLICATION_PATH)/tools/xpack-arm-none-eabi-gcc/$(STM32DUINO_GCC_ARM_RELEASE)
# OTHER_TOOLS_PATH = $(APPLICATION_PATH)/tools/RFDLoader/1.5
OTHER_TOOLS_PATH = $(APPLICATION_PATH)/tools/STM32Tools/$(STM32DUINO_RELEASE)/tools/macosx

APP_TOOLS_PATH := $(TOOL_CHAIN_PATH)/bin
APP_LIB_PATH := $(HARDWARE_PATH)/libraries
BOARDS_TXT := $(HARDWARE_PATH)/boards.txt

CMSIS_PATH = $(STM32DUINO_INITIAL)/tools/CMSIS/$(STM32DUINO_CMSIS_RELEASE)

PLATFORM := STM32duino
SUB_PLATFORM = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.core)

BUILD_CORE = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.core)
BUILD_SERIES = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.series)
BUILD_BOARD = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.board)

PLATFORM_TAG = EMCODE=$(RELEASE_NOW) ARDUINO=$(RELEASE_ARDUINO) STM32DUINO ARDUINO_$(BUILD_BOARD) ARDUINO_$(BUILD_SERIES) ARDUINO_ARCH_STM32 $(BUILD_SERIES) $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.product_line) BOARD_NAME='"$(BUILD_BOARD)"'

# Generate main.cpp
# ----------------------------------
#
ifneq ($(strip $(KEEP_MAIN)),true)
PATH_TO_MAIN_CPP = $(HARDWARE_PATH)/cores/arduino
$(shell echo "// " > ./main.cpp)
$(shell echo "// main.cpp generated by emCode" >> ./main.cpp)
$(shell echo "// from $(PATH_TO_MAIN_CPP)" >> ./main.cpp)
$(shell echo "// at $$(date +'%d %b %Y %T')" >> ./main.cpp)
$(shell echo "// ----------------------------------" >> ./main.cpp)
$(shell echo "// DO NOT EDIT THIS FILE." >> ./main.cpp)
$(shell echo "// ----------------------------------" >> ./main.cpp)
$(shell echo "#if defined(EMCODE)" >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
# $(shell echo "#include <SrcWrapper.h>" >> ./main.cpp)
# $(shell echo " " >> ./main.cpp)
$(shell cat $(PATH_TO_MAIN_CPP)/main.cpp >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo "#include \"$(PROJECT_NAME_AS_IDENTIFIER).$(SKETCH_EXTENSION)\"" >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo "#endif // EMCODE" >> ./main.cpp)
endif

# Uploader
#
ifeq ($(UPLOADER),stlink)
    UPLOADER_EXEC = st-flash
    UPLOADER_OPTS = --reset --format ihex write
    COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) $(TARGET_HEX)
    DEBUG_SERVER = stlink

    UPLOADER_EXEC = $(STM32_CUBE_PATH)/bin/STM32_Programmer_CLI
    UPLOADER_OPTS = -c port=SWD mode=UR -q -d $(TARGET_HEX) -rst
    COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS)

else ifeq ($(UPLOADER),cp_hex)
    TARGET_BIN_CP = $(TARGET_HEX)
    DEBUG_SERVER = stlink
    USED_VOLUME_PORT = $(strip $(BOARD_VOLUME))

else ifeq ($(UPLOADER),openocd)
	UPLOADER_EXEC = openocd
    UPLOADER_OPTS = -f interface/stlink.cfg 
    ifeq ($(findstring NUCLEO_L4,$(BOARD_NAME)),)
        UPLOADER_OPTS += -f board/st_nucleo_l4.cfg 
    else
        UPLOADER_OPTS += -f board/st_nucleo_f4.cfg 
    endif
    UPLOADER_OPTS += -c "program $(TARGET_ELF) verify reset ; exit"
    COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS)
    DEBUG_SERVER = openocd
#     DEBUGGER_OPTS = -f board/st_nucleo_f4.cfg

else # UPLOADER


endif # UPLOADER

# Tool-chain names
#
CC = $(APP_TOOLS_PATH)/arm-none-eabi-gcc
CXX = $(APP_TOOLS_PATH)/arm-none-eabi-g++
AR = $(APP_TOOLS_PATH)/arm-none-eabi-ar
OBJDUMP = $(APP_TOOLS_PATH)/arm-none-eabi-objdump
OBJCOPY = $(APP_TOOLS_PATH)/arm-none-eabi-objcopy
SIZE = $(APP_TOOLS_PATH)/arm-none-eabi-size
NM = $(APP_TOOLS_PATH)/arm-none-eabi-nm
GDB = $(APP_TOOLS_PATH)/arm-none-eabi-gdb

LDSCRIPT = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.ldscript)
VARIANT = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.variant)

# Multiple locations for core libraries
#
# CORE_LIB_PATH := $(HARDWARE_PATH)/cores/arduino
CORE_LIB_PATH := $(shell find $(HARDWARE_PATH)/cores/arduino -type d)
SYSTEM_LIB_PATH := $(HARDWARE_PATH)/system

CORE_C_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.c))
CORE_CPP_SRCS = $(filter-out %main.cpp,$(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.cpp)))

CORE_AS1_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.S))
CORE_AS2_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.s))

CORE_AS1_SRCS_OBJ = $(patsubst %.S,%.S.o,$(filter %S, $(CORE_AS1_SRCS)))
CORE_AS2_SRCS_OBJ = $(patsubst %.s,%.s.o,$(filter %s, $(CORE_AS2_SRCS)))

CORE_H_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.h))

CORE_OBJ_FILES += $(CORE_C_SRCS:.c=.c.o) $(CORE_CPP_SRCS:.cpp=.cpp.o) $(CORE_AS1_SRCS_OBJ) $(CORE_AS2_SRCS_OBJ)
CORE_OBJS += $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(CORE_OBJ_FILES))

CORE_LIBS_LOCK = 1

BUILD_CORE_LIB_PATH := $(shell find $(HARDWARE_PATH)/libraries/SrcWrapper -type d)

BUILD_CORE_C_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.c))
BUILD_CORE_CPP_SRCS = $(filter-out %main.cpp,$(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.cpp)))

BUILD_CORE_AS1_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.S))
BUILD_CORE_AS2_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.s))

BUILD_CORE_AS1_SRCS_OBJ = $(patsubst %.S,%.S.o,$(filter %S, $(BUILD_CORE_AS1_SRCS)))
BUILD_CORE_AS2_SRCS_OBJ = $(patsubst %.s,%.s.o,$(filter %s, $(BUILD_CORE_AS2_SRCS)))

BUILD_CORE_H_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.h))

BUILD_CORE_OBJ_FILES += $(BUILD_CORE_C_SRCS:.c=.c.o) $(BUILD_CORE_CPP_SRCS:.cpp=.cpp.o) $(BUILD_CORE_AS1_SRCS_OBJ) $(BUILD_CORE_AS2_SRCS_OBJ)
BUILD_CORE_OBJS += $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(BUILD_CORE_OBJ_FILES))

# Variant libraries
#
VARIANT_PATH = $(HARDWARE_PATH)/variants/$(VARIANT)

VARIANT_CPP_SRCS = $(wildcard $(VARIANT_PATH)/*.cpp)
VARIANT_C_SRCS = $(wildcard $(VARIANT_PATH)/*.c)

VARIANT_OBJ_FILES = $(VARIANT_CPP_SRCS:.cpp=.cpp.o) $(VARIANT_C_SRCS:.c=.c.o)
VARIANT_OBJS = $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(VARIANT_OBJ_FILES))

F_CPU = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.f_cpu)
MCU = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.mcu)
ifeq ($(F_CPU),)
    F_CPU = 72000000L
endif
ifeq ($(MCU),)
    MCU = cortex-m3
endif
MCU_FLAG_NAME = mcpu

INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/avr
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32
INCLUDE_PATH += $(HARDWARE_PATH)/libraries/SrcWrapper/inc
INCLUDE_PATH += $(HARDWARE_PATH)/libraries/SrcWrapper/inc/LL

INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/$(BUILD_SERIES)_HAL_Driver/Inc
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/$(BUILD_SERIES)_HAL_Driver/Src
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/$(BUILD_SERIES)
INCLUDE_PATH += $(HARDWARE_PATH)/libraries/USBDevice/inc
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/ST/STM32_USB_Device_Library/Core/Inc
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/ST/STM32_USB_Device_Library/Core/Src
INCLUDE_PATH += $(HARDWARE_PATH)/libraries/VirtIO/inc
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP/open-amp/lib/include
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP/libmetal/lib/include
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP/virtual_driver

INCLUDE_PATH += $(CMSIS_PATH)/CMSIS/Core/Include/
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/CMSIS/Device/ST/$(BUILD_SERIES)/Include/
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/CMSIS/Device/ST/$(BUILD_SERIES)/Source/Templates/gcc/
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino

INCLUDE_PATH += $(CMSIS_PATH)/CMSIS/DSP/Include
INCLUDE_PATH += $(CMSIS_PATH)/CMSIS/DSP/PrivateInclude

# INCLUDE_PATH += -DINCLUDE_PATH_3
# INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/LL
# INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/usb
# INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/OpenAMP
# INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/usb/hid
# INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/usb/cdc

# compiler.stm.extra_include="-I{build.source.path}" "-I{build.core.path}/avr" "-I{core_stm32_dir}" "-I{SrcWrapper_include_dir}" "-I{SrcWrapper_include_dir}/LL" "-I{hal_dir}/Inc" "-I{hal_dir}/Src" "-I{build.system.path}/{build.series}" "-I{USBDevice_include_dir}" "-I{usbd_core_dir}/Inc" "-I{usbd_core_dir}/Src" "-I{VirtIO_include_dir}" {build.virtio_extra_include}
# compiler.arm.cmsis.c.flags="-I{cmsis_dir}/Core/Include/" "-I{cmsis_dev_dir}/Include/" "-I{cmsis_dev_dir}/Source/Templates/gcc/" "-I{cmsis_dir}/DSP/Include" "-I{cmsis_dir}/DSP/PrivateInclude"

# INCLUDE_PATH += $(HARDWARE_PATH)/Drivers/$(BUILD_SERIES)_HAL_Driver
# INCLUDE_PATH += $(HARDWARE_PATH)/Middlewares/ST/STM32_USB_Device_Library/Core

#  F_CPU
FLAGS_FPU = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.flags.fp)
FLAGS_FPU += $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.fpu)
FLAGS_FPU += $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.float-abi)

# Protect strange paths
INCLUDE_PATH := $(patsubst %,"%",$(INCLUDE_PATH))

FLAGS_L += $(CMSIS_PATH)/CMSIS/DSP/Lib/GCC/

# FLAGS_D = L_UART_MODULE_ENABLED
stm1400a = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.variant_h)
stm1400b = $(call PARSE_BOARD,$(BOARD_TAG),build.variant_h)
stm1400c = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.variant_h)
stm1400d = $(shell echo $(stm1400c) | sed 's:{build.board}:$(BUILD_BOARD):')

FLAGS_D += VARIANT_H='"$(stm1400d)"'

# MORE_DFLAGS = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.extra_flags)
# ifeq ($(MORE_DFLAGS),)
#    MORE_DFLAGS = -DMCU_STM32F103CB -mthumb -DSERIAL_USB -march=armv7-m -D__STM32F1__
# endif
FLASH_OFFSET = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.flash_offset)
ifeq ($(FLASH_OFFSET),)
    FLASH_OFFSET = 0
endif
MAX_FLASH_SIZE = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),upload.maximum_size)
ifeq ($(MAX_FLASH_SIZE),)
    MAX_FLASH_SIZE = $(call SEARCH_FOR,$(BOARD_TAG),upload.maximum_size)
endif
MAX_RAM_SIZE = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),upload.maximum_data_size)
ifeq ($(MAX_RAM_SIZE),)
    MAX_RAM_SIZE = $(call SEARCH_FOR,$(BOARD_TAG),upload.maximum_data_size)
endif

# $(info *** MAX_FLASH_SIZE '$(MAX_FLASH_SIZE)')
# $(info *** MAX_RAM_SIZE '$(MAX_RAM_SIZE)')

# platform.txt build.usb_flags=-DUSBCON {build.usb_speed} -DUSBD_VID={build.vid} -DUSBD_PID={build.pid} -DHAL_PCD_MODULE_ENABLED
stm1000a = $(call PARSE_FILE,build,usb_flags=,$(HARDWARE_PATH)/platform.txt)

# boards.txt for build.usb_speed build.vid build.pid
BUILD_USB_SPEED = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.usb_speed)
BUILD_VID = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.vid)
BUILD_PID = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.pid)

stm1000b = $(shell echo '$(stm1000a)' | sed 's:{build.usb_speed}:$(BUILD_USB_SPEED):g')
stm1000c = $(shell echo '$(stm1000b)' | sed 's:{build.vid}:$(BUILD_VID):g')
stm1000d = $(shell echo '$(stm1000c)' | sed 's:{build.pid}:$(BUILD_PID):g')

BUILD_USB_FLAGS = $(stm1000d)

# boards.txt build.enable_usb={build.usb_flags} -DUSBD_USE_CDC
stm1200a = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.enable_usb)

stm1200b = $(shell echo '$(stm1200a)' | sed 's:{build.usb_flags}:$(BUILD_USB_FLAGS):g')

BUILD_ENABLE_USB = $(stm1200b) 

# $(info >>> BOARD_TAGS_LIST $(BOARD_TAGS_LIST))

# $(info >>> stm1000)
# $(info >>> stm1000a $(stm1000a))
# $(info >>> stm1000b $(stm1000b))
# $(info >>> stm1000c $(stm1000c))
# $(info >>> stm1000d $(stm1000d))

# $(info >>> stm1200)
# $(info >>> stm1200a $(stm1200a))
# $(info >>> stm1200b $(stm1200b))

# platform.txt build.st_extra_flags=-D{build.product_line} {build.enable_usb} {build.xSerial}
stm1100a = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.st_extra_flags)

# boards.txt for build.bootloader_flags build.enable_virtio build.product_line build.xSerial
BUILD_BOOTLOADER_FLAGS = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.bootloader_flags)
BUILD_ENABLE_VIRTIO = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.enable_virtio)
BUILD_PRODUCT_LINE = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.product_line)

BUILD_XSERIAL = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.xSerial)
ifeq ($(BUILD_XSERIAL),)
    BUILD_XSERIAL := -DHAL_UART_MODULE_ENABLED
endif

stm1100b = $(shell echo '$(stm1100a)' | sed 's:{build.bootloader_flags}:$(BUILD_BOOTLOADER_FLAGS):g')
stm1100c = $(shell echo '$(stm1100b)' | sed 's:{build.enable_virtio}:$(BUILD_ENABLE_VIRTIO):g')
stm1100d = $(shell echo '$(stm1100c)' | sed 's:{build.product_line}:$(BUILD_PRODUCT_LINE):g')
stm1100e = $(shell echo '$(stm1100d)' | sed 's:{build.xSerial}:$(BUILD_XSERIAL):g')
stm1100f = $(shell echo '$(stm1100e)' | sed 's:{build.enable_usb}:$(BUILD_ENABLE_USB):g')

BUILD_ST_EXTRA_FLAGS = $(stm1100f)

# $(info >>> stm1100)
# $(info >>> stm1100a $(stm1100a))
# $(info >>> stm1100b $(stm1100b))
# $(info >>> stm1100c $(stm1100c))
# $(info >>> stm1100d $(stm1100d))
# $(info >>> stm1100e $(stm1100e))
# $(info >>> stm1100f $(stm1100f))

# # Create {build.opt} if not exists in the output sketch dir and force include of SrcWrapper library
# recipe.hooks.prebuild.1.pattern="{busybox}" sh "{extras.path}/prebuild.sh" "{build.path}" "{build.source.path}" "{runtime.platform.path}" "usb={build.enable_usb}" "virtio={build.enable_virtio}"
# recipe.hooks.postbuild.1.pattern="{busybox}" sh "{extras.path}/postbuild.sh" "{build.path}" "{build.series}" "{runtime.platform.path}"

BUILD_SERIES = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.series)

COMMAND_BEFORE_COMPILE = sh $(SYSTEM_LIB_PATH)/extras/prebuild.sh $(BUILDS_PATH) $(CURRENT_DIR) $(HARDWARE_PATH) usb=$(BUILD_ENABLE_USB) virtio=$(BUILD_ENABLE_VIRTIO)

MESSAGE_BEFORE = "Set build options"

# COMMAND_AFTER_COMPILE = sh $(SYSTEM_LIB_PATH)/extras/postbuild.sh $(BUILDS_PATH) $(BUILD_SERIES) $(HARDWARE_PATH)

# MESSAGE_AFTER = "Clean build options"

# Flags for gcc, g++ and linker
# ----------------------------------
#
# Common FLAGS_ALL for gcc, g++, assembler and linker
#
FLAGS_ALL = $(OPTIMISATION) $(FLAGS_WARNING)
FLAGS_ALL += -$(MCU_FLAG_NAME)=$(MCU) -DF_CPU=$(F_CPU) 
FLAGS_ALL += $(FLAGS_FPU)

FLAGS_ALL += -DVECT_TAB_OFFSET=$(FLASH_OFFSET)
FLAGS_ALL += -DUSE_HAL_DRIVER -DUSE_FULL_LL_DRIVER -mthumb
FLAGS_ALL += -ffunction-sections -fdata-sections
FLAGS_ALL += --param max-inline-insns-single=500 -MMD
# FLAGS_ALL += -nostdlib -fno-threadsafe-statics
FLAGS_ALL += $(addprefix -D, $(PLATFORM_TAG) $(FLAGS_D)) $(MORE_DFLAGS) # printf=iprintf
FLAGS_ALL += -mthumb
FLAGS_ALL += @$(BUILDS_PATH)/sketch/build.opt
# $(USB_FLAGS)
FLAGS_ALL += $(addprefix -I, $(INCLUDE_PATH)) -I"$(VARIANT_PATH)"

FLAGS_ALL += $(BUILD_ST_EXTRA_FLAGS)

# Specific FLAGS_C for gcc only
# gcc uses FLAGS_ALL and FLAGS_C
#
FLAGS_C = -std=gnu17

# Specific FLAGS_CPP for g++ only
# g++ uses FLAGS_ALL and FLAGS_CPP
#
FLAGS_CPP = -fno-threadsafe-statics -fno-rtti -fno-exceptions -fno-use-cxa-atexit -std=gnu++17

# Specific FLAGS_AS for gcc assembler only
# gcc assembler uses FLAGS_ALL and FLAGS_AS
#
FLAGS_AS = -x assembler-with-cpp

# Specific FLAGS_LD for linker only
# linker uses FLAGS_ALL and FLAGS_LD
#
FLAGS_LD = $(OPTIMISATION) $(FLAGS_WARNING)
FLAGS_LD += -$(MCU_FLAG_NAME)=$(MCU) -mthumb
FLAGS_LD += $(addprefix -L, $(FLAGS_L))
# FLAGS_LD += -l$(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.cmsis_lib_gcc)
FLAGS_LD += -Wl,-Map,$(OBJDIR)/emCode.cpp.map # Output a cross reference table.
# With 1.8.0
ifeq ($(STM32DUINO_RELEASE),1.8.0)
    FLAGS_LD += -T $(VARIANT_PATH)/ldscript.ld
else
#     With 1.9.0
    FLAGS_LD += -Wl,--default-script="$(VARIANT_PATH)/ldscript.ld"
    FLAGS_LD += -Wl,--script="$(SYSTEM_LIB_PATH)/ldscript.ld"
endif
FLAGS_LD += -Wl,--no-warn-rwx-segments

FLAGS_LD += -L$(BUILDS_PATH)
FLAGS_LD += $(addprefix -D, $(PLATFORM_TAG)) 

FLAGS_LD += $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.flags.fp)
FLAGS_LD += --specs=nano.specs
FLAGS_LD += -Wl,--defsym=LD_FLASH_OFFSET=$(FLASH_OFFSET)
FLAGS_LD += -Wl,--defsym=LD_MAX_SIZE=$(MAX_FLASH_SIZE)
FLAGS_LD += -Wl,--defsym=LD_MAX_DATA_SIZE=$(MAX_RAM_SIZE)
FLAGS_LD += -Wl,--cref -Wl,--check-sections -Wl,--gc-sections
FLAGS_LD += -Wl,--entry=Reset_Handler -Wl,--unresolved-symbols=report-all
FLAGS_LD += -Wl,--warn-common
FLAGS_LD += $(FLAGS_FPU)

FLAGS_LD_2 += -lc -lm -lgcc -lstdc++

INCLUDE_A = $(wildcard $(VARIANT_PATH)/*.a)

# Specific FLAGS_OBJCOPY for objcopy only
# objcopy uses FLAGS_OBJCOPY only
#
FLAGS_OBJCOPY = -v -Oihex

# Target
#
TARGET_HEXBIN = $(TARGET_HEX)
# TARGET_EEP = $(TARGET_HEX)
COMMAND_COPY = $(OBJCOPY) -O binary $< $(TARGET_HEX)
COMMAND_POST_COPY = $(OBJCOPY) -O ihex $< $(TARGET_HEX)

# MAX_RAM_SIZE = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),upload.ram.maximum_size)

# Commands
# ----------------------------------
#
# FIRST_O_IN_LD = $$(find $(BUILDS_PATH) -name *.s.o) $$(find $(BUILDS_PATH) -name variant.cpp.o)

# Link command
#
# COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_O_IN_LD) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) -Wl,--end-group
# COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_O_IN_LD) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) -lc -Wl,--end-group -lm -lgcc -lstdc++
# COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(REMOTE_OBJS) $(LOCAL_OBJS) -lc -Wl,--end-group -lm -lgcc -lstdc++
## COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_O_IN_LD) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) -lc -Wl,--end-group -lm -lgcc -lstdc++
COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_OBJS_IN_LINK) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) $(TARGET_CORE_A) -lc -Wl,--end-group -lm -lgcc -lstdc++

#$(FLAGS_LD_2)

# Upload command
#
# COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_PORT) $(UPLOADER_OPTS) $(TARGET_BIN)

endif # BOARD_CHECK

endif # MAKEFILE_NAME

