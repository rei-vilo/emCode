#
# emCode
# ----------------------------------
# Embedded computing with make
#
# Copyright © Rei Vilo, 2010-2023
# All rights reserved
#
# Last update: 16 Jan 2023 release 13.0.0
#

ifeq ($(MAKEFILE_NAME),)

STM32DUINO_INITIAL = $(ARDUINO_PACKAGES_PATH)/STMicroelectronics

ifneq ($(wildcard $(STM32DUINO_INITIAL)/hardware/stm32),)
    STM32DUINO_APP = $(STM32DUINO_INITIAL)
    STM32DUINO_PATH = $(STM32DUINO_APP)
    STM32DUINO_BOARDS = $(STM32DUINO_APP)/hardware/stm32/$(STM32DUINO_RELEASE)/boards.txt
endif

BOARD_CHECK := 0
ifneq ($(filter STM32DUINO,$(GCC_PREPROCESSOR_DEFINITIONS)),)
ifneq ($(call PARSE_FILE,$(BOARD_TAG),name,$(STM32DUINO_BOARDS)),)
    BOARD_CHECK := 1
endif
endif

ifeq ($(BOARD_CHECK),1)
MAKEFILE_NAME = STM32duino
RELEASE_CORE = $(STM32DUINO_RELEASE)
READY_FOR_EMCODE_NEXT = 1

# Complicated menu system for Arduino 1.5
# Another example of Arduino's quick and dirty job
#
BOARD_TAGS_LIST = $(BOARD_TAG) $(BOARD_TAG1) $(BOARD_TAG2) $(BOARD_TAG3)
BOARD_OPTION_TAGS_LIST = $(BOARD_TAG1) $(BOARD_TAG2) $(BOARD_TAG3)

# SEARCH_FOR = $(strip $(foreach t,$(1),$(call PARSE_BOARD,$(t),$(2))))

# STM32duino specifics
# ----------------------------------
#
APPLICATION_PATH := $(STM32DUINO_PATH)
PLATFORM_VERSION := STM32duino $(STM32DUINO_RELEASE) for Arduino $(ARDUINO_IDE_RELEASE)

HARDWARE_PATH = $(APPLICATION_PATH)/hardware/stm32/$(STM32DUINO_RELEASE)
TOOL_CHAIN_PATH = $(APPLICATION_PATH)/tools/xpack-arm-none-eabi-gcc/$(STM32DUINO_GCC_ARM_RELEASE)
# OTHER_TOOLS_PATH = $(APPLICATION_PATH)/tools/RFDLoader/1.5
OTHER_TOOLS_PATH = $(APPLICATION_PATH)/tools/STM32Tools/$(STM32DUINO_RELEASE)/tools/macosx

APP_TOOLS_PATH := $(TOOL_CHAIN_PATH)/bin
APP_LIB_PATH := $(HARDWARE_PATH)/libraries
BOARDS_TXT := $(HARDWARE_PATH)/boards.txt

CMSIS_PATH = $(STM32DUINO_INITIAL)/tools/CMSIS/$(STM32DUINO_CMSIS_RELEASE)

PLATFORM := STM32duino
SUB_PLATFORM = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.core)

BUILD_CORE = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.core)
BUILD_SERIES = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.series)
BUILD_BOARD = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.board)

PLATFORM_TAG = EMCODE=$(RELEASE_NOW) ARDUINO=$(RELEASE_ARDUINO) STM32DUINO ARDUINO_$(BUILD_BOARD) ARDUINO_$(BUILD_SERIES) ARDUINO_ARCH_STM32 $(BUILD_SERIES) $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.product_line) BOARD_NAME='"$(BUILD_BOARD)"'

# Generate main.cpp
# ----------------------------------
#
ifneq ($(strip $(KEEP_MAIN)),true)
PATH_TO_MAIN_CPP = $(HARDWARE_PATH)/cores/arduino
$(shell echo "// " > ./main.cpp)
$(shell echo "// main.cpp generated by emCode" >> ./main.cpp)
$(shell echo "// from $(PATH_TO_MAIN_CPP)" >> ./main.cpp)
$(shell echo "// at $$(date +'%d %b %Y %T')" >> ./main.cpp)
$(shell echo "// ----------------------------------" >> ./main.cpp)
$(shell echo "// DO NOT EDIT THIS FILE." >> ./main.cpp)
$(shell echo "// ----------------------------------" >> ./main.cpp)
$(shell echo "#if defined(EMCODE)" >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
# $(shell echo "#include <SrcWrapper.h>" >> ./main.cpp)
# $(shell echo " " >> ./main.cpp)
$(shell cat $(PATH_TO_MAIN_CPP)/main.cpp >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo "#include \"$(PROJECT_NAME_AS_IDENTIFIER).$(SKETCH_EXTENSION)\"" >> ./main.cpp)
$(shell echo " " >> ./main.cpp)
$(shell echo "#endif // EMCODE" >> ./main.cpp)
endif

# Uploader
#
ifeq ($(UPLOADER),stlink)
    UPLOADER_EXEC = st-flash
    UPLOADER_OPTS = --reset --format ihex write
    COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS) $(TARGET_HEX)
    DEBUG_SERVER = stlink

    UPLOADER_EXEC = $(STM32_CUBE_PATH)/bin/STM32_Programmer_CLI
    UPLOADER_OPTS = -c port=SWD mode=UR -q -d $(TARGET_HEX) -rst
    COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS)

else ifeq ($(UPLOADER),cp_hex)
    TARGET_BIN_CP = $(TARGET_HEX)
    DEBUG_SERVER = stlink
    USED_VOLUME_PORT = $(strip $(BOARD_VOLUME))

else ifeq ($(UPLOADER),openocd)
	UPLOADER_EXEC = openocd
    UPLOADER_OPTS = -f interface/stlink.cfg 
    ifeq ($(findstring NUCLEO_L4,$(BOARD_NAME)),)
        UPLOADER_OPTS += -f board/st_nucleo_l4.cfg 
    else
        UPLOADER_OPTS += -f board/st_nucleo_f4.cfg 
    endif
    UPLOADER_OPTS += -c "program $(TARGET_ELF) verify reset ; exit"
    COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_OPTS)
    DEBUG_SERVER = openocd
    # DEBUGGER_OPTS = -f board/st_nucleo_f4.cfg
else

endif

# Tool-chain names
#
CC = $(APP_TOOLS_PATH)/arm-none-eabi-gcc
CXX = $(APP_TOOLS_PATH)/arm-none-eabi-g++
AR = $(APP_TOOLS_PATH)/arm-none-eabi-ar
OBJDUMP = $(APP_TOOLS_PATH)/arm-none-eabi-objdump
OBJCOPY = $(APP_TOOLS_PATH)/arm-none-eabi-objcopy
SIZE = $(APP_TOOLS_PATH)/arm-none-eabi-size
NM = $(APP_TOOLS_PATH)/arm-none-eabi-nm
GDB = $(APP_TOOLS_PATH)/arm-none-eabi-gdb

LDSCRIPT = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.ldscript)
VARIANT = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.variant)

# Multiple locations for core libraries
#
# CORE_LIB_PATH := $(HARDWARE_PATH)/cores/arduino
CORE_LIB_PATH := $(shell find $(HARDWARE_PATH)/cores/arduino -type d)
SYSTEM_LIB_PATH := $(HARDWARE_PATH)/system

CORE_C_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.c))
CORE_CPP_SRCS = $(filter-out %main.cpp,$(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.cpp)))

CORE_AS1_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.S))
CORE_AS2_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.s))

CORE_AS1_SRCS_OBJ = $(patsubst %.S,%.S.o,$(filter %S, $(CORE_AS1_SRCS)))
CORE_AS2_SRCS_OBJ = $(patsubst %.s,%.s.o,$(filter %s, $(CORE_AS2_SRCS)))

CORE_H_SRCS = $(foreach dir,$(CORE_LIB_PATH),$(wildcard $(dir)/*.h))

CORE_OBJ_FILES += $(CORE_C_SRCS:.c=.c.o) $(CORE_CPP_SRCS:.cpp=.cpp.o) $(CORE_AS1_SRCS_OBJ) $(CORE_AS2_SRCS_OBJ)
CORE_OBJS += $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(CORE_OBJ_FILES))

CORE_LIBS_LOCK = 1

BUILD_CORE_LIB_PATH := $(shell find $(HARDWARE_PATH)/libraries/SrcWrapper -type d)

BUILD_CORE_C_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.c))
BUILD_CORE_CPP_SRCS = $(filter-out %main.cpp,$(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.cpp)))

BUILD_CORE_AS1_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.S))
BUILD_CORE_AS2_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.s))

BUILD_CORE_AS1_SRCS_OBJ = $(patsubst %.S,%.S.o,$(filter %S, $(BUILD_CORE_AS1_SRCS)))
BUILD_CORE_AS2_SRCS_OBJ = $(patsubst %.s,%.s.o,$(filter %s, $(BUILD_CORE_AS2_SRCS)))

BUILD_CORE_H_SRCS = $(foreach dir,$(BUILD_CORE_LIB_PATH),$(wildcard $(dir)/*.h))

BUILD_CORE_OBJ_FILES += $(BUILD_CORE_C_SRCS:.c=.c.o) $(BUILD_CORE_CPP_SRCS:.cpp=.cpp.o) $(BUILD_CORE_AS1_SRCS_OBJ) $(BUILD_CORE_AS2_SRCS_OBJ)
BUILD_CORE_OBJS += $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(BUILD_CORE_OBJ_FILES))

# Variant libraries
#
VARIANT_PATH = $(HARDWARE_PATH)/variants/$(VARIANT)

VARIANT_CPP_SRCS = $(wildcard $(VARIANT_PATH)/*.cpp)
VARIANT_C_SRCS = $(wildcard $(VARIANT_PATH)/*.c)

VARIANT_OBJ_FILES = $(VARIANT_CPP_SRCS:.cpp=.cpp.o) $(VARIANT_C_SRCS:.c=.c.o)
VARIANT_OBJS = $(patsubst $(HARDWARE_PATH)/%,$(OBJDIR)/%,$(VARIANT_OBJ_FILES))

F_CPU = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.f_cpu)
MCU = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.mcu)
ifeq ($(F_CPU),)
    F_CPU = 72000000L
endif
ifeq ($(MCU),)
    MCU = cortex-m3
endif
MCU_FLAG_NAME = mcpu

INCLUDE_PATH = $(HARDWARE_PATH)/cores/arduino
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/avr
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/LL
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/usb
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/OpenAMP
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/usb/hid
INCLUDE_PATH += $(HARDWARE_PATH)/cores/arduino/stm32/usb/cdc
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/$(BUILD_SERIES)_HAL_Driver/Inc
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/$(BUILD_SERIES)_HAL_Driver/Src
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/$(BUILD_SERIES)
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/ST/STM32_USB_Device_Library/Core/Inc
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/ST/STM32_USB_Device_Library/Core/Src
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP/open-amp/lib/include
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP/libmetal/lib/include
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Middlewares/OpenAMP/virtual_driver

INCLUDE_PATH += $(CMSIS_PATH)/CMSIS/Core/Include/
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/CMSIS/Device/ST/$(BUILD_SERIES)/Include/
INCLUDE_PATH += $(SYSTEM_LIB_PATH)/Drivers/CMSIS/Device/ST/$(BUILD_SERIES)/Source/Templates/gcc/
INCLUDE_PATH += $(CMSIS_PATH)/CMSIS/DSP/Include
INCLUDE_PATH += $(CMSIS_PATH)/CMSIS/DSP/PrivateInclude

#  F_CPU
FLAGS_FPU = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.flags.fp)
FLAGS_FPU += $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.fpu)
FLAGS_FPU += $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.float-abi)

# Protect strange paths
INCLUDE_PATH := $(patsubst %,"%",$(INCLUDE_PATH))

FLAGS_L += $(CMSIS_PATH)/CMSIS/DSP/Lib/GCC/

FLAGS_D = HAL_UART_MODULE_ENABLED
stm1400a = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),build.variant_h)
stm1400b = $(call PARSE_BOARD,$(BOARD_TAG),build.variant_h)
stm1400c = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.variant_h)
stm1400d = $(shell echo $(stm1400c) | sed 's:{build.board}:$(BUILD_BOARD):')

FLAGS_D += VARIANT_H='"$(stm1400d)"'

# MORE_DFLAGS = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.extra_flags)
# ifeq ($(MORE_DFLAGS),)
#    MORE_DFLAGS = -DMCU_STM32F103CB -mthumb -DSERIAL_USB -march=armv7-m -D__STM32F1__
# endif
FLASH_OFFSET = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.flash_offset)
ifeq ($(FLASH_OFFSET),)
    FLASH_OFFSET = 0
endif
MAX_FLASH_SIZE = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),upload.maximum_size)
ifeq ($(MAX_FLASH_SIZE),)
    MAX_FLASH_SIZE = $(call SEARCH_FOR,$(BOARD_TAG),upload.maximum_size)
endif
MAX_RAM_SIZE = $(call SEARCH_FOR,$(BOARD_OPTION_TAGS_LIST),upload.maximum_data_size)
ifeq ($(MAX_RAM_SIZE),)
    MAX_RAM_SIZE = $(call SEARCH_FOR,$(BOARD_TAG),upload.maximum_data_size)
endif

FLAG_D += $(VECT_TAB_OFFSET=$(FLASH_OFFSET))

# $(info *** MAX_FLASH_SIZE '$(MAX_FLASH_SIZE)')
# $(info *** MAX_RAM_SIZE '$(MAX_RAM_SIZE)')

COMMAND_BEFORE_COMPILE = touch $(BUILDS_PATH)/build_opt.h

MESSAGE_BEFORE = "Set build options"

# Flags for gcc, g++ and linker
# ----------------------------------
#
# Common FLAGS_ALL for gcc, g++, assembler and linker
#
FLAGS_ALL = $(OPTIMISATION) $(FLAGS_WARNING)
FLAGS_ALL += -$(MCU_FLAG_NAME)=$(MCU) -DF_CPU=$(F_CPU) -DUSE_FULL_LL_DRIVER
FLAGS_ALL += -ffunction-sections -fdata-sections
FLAGS_ALL += -nostdlib -fno-threadsafe-statics
FLAGS_ALL += --param max-inline-insns-single=500 -MMD
FLAGS_ALL += $(addprefix -D, $(PLATFORM_TAG) $(FLAGS_D)) $(MORE_DFLAGS) # printf=iprintf
FLAGS_ALL += -mthumb
FLAGS_ALL += @$(BUILDS_PATH)/build_opt.h
# $(USB_FLAGS)
FLAGS_ALL += $(addprefix -I, $(INCLUDE_PATH)) -I"$(VARIANT_PATH)"
FLAGS_ALL += $(FLAGS_FPU)

# Specific FLAGS_C for gcc only
# gcc uses FLAGS_ALL and FLAGS_C
#
FLAGS_C = -std=gnu11

# Specific FLAGS_CPP for g++ only
# g++ uses FLAGS_ALL and FLAGS_CPP
#
FLAGS_CPP = -fno-rtti -fno-exceptions -fno-use-cxa-atexit -std=gnu++14

# Specific FLAGS_AS for gcc assembler only
# gcc assembler uses FLAGS_ALL and FLAGS_AS
#
FLAGS_AS = -x assembler-with-cpp

# Specific FLAGS_LD for linker only
# linker uses FLAGS_ALL and FLAGS_LD
#
FLAGS_LD = $(OPTIMISATION) $(FLAGS_WARNING)
FLAGS_LD += -$(MCU_FLAG_NAME)=$(MCU) -mthumb
FLAGS_LD += $(addprefix -L, $(FLAGS_L))
FLAGS_LD += -l$(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.cmsis_lib_gcc)
FLAGS_LD += -Wl,-Map,$(OBJDIR)/emCode.cpp.map # Output a cross reference table.
# With 1.8.0
ifeq ($(STM32DUINO_RELEASE),1.8.0)
    FLAGS_LD += -T $(VARIANT_PATH)/ldscript.ld
else
    # With 1.9.0
    FLAGS_LD += -Wl,--default-script="$(VARIANT_PATH)/ldscript.ld"
    FLAGS_LD += -Wl,--script="$(SYSTEM_LIB_PATH)/ldscript.ld"
endif
FLAGS_LD += -Wl,--no-warn-rwx-segments

FLAGS_LD += -L$(BUILDS_PATH)
FLAGS_LD += $(addprefix -D, $(PLATFORM_TAG)) 

FLAGS_LD += $(call SEARCH_FOR,$(BOARD_TAGS_LIST),build.flags.fp)
FLAGS_LD += --specs=nano.specs
FLAGS_LD += -Wl,--defsym=LD_FLASH_OFFSET=$(FLASH_OFFSET)
FLAGS_LD += -Wl,--defsym=LD_MAX_SIZE=$(MAX_FLASH_SIZE)
FLAGS_LD += -Wl,--defsym=LD_MAX_DATA_SIZE=$(MAX_RAM_SIZE)
FLAGS_LD += -Wl,--cref -Wl,--check-sections -Wl,--gc-sections
FLAGS_LD += -Wl,--entry=Reset_Handler -Wl,--unresolved-symbols=report-all
FLAGS_LD += -Wl,--warn-common
FLAGS_LD += $(FLAGS_FPU)

FLAGS_LD_2 += -lc -lm -lgcc -lstdc++

INCLUDE_A = $(wildcard $(VARIANT_PATH)/*.a)

# Specific FLAGS_OBJCOPY for objcopy only
# objcopy uses FLAGS_OBJCOPY only
#
FLAGS_OBJCOPY = -v -Oihex

# Target
#
TARGET_HEXBIN = $(TARGET_HEX)
# TARGET_EEP = $(TARGET_HEX)
COMMAND_COPY = $(OBJCOPY) -O binary $< $(TARGET_HEX)
COMMAND_POST_COPY = $(OBJCOPY) -O ihex $< $(TARGET_HEX)

# MAX_RAM_SIZE = $(call SEARCH_FOR,$(BOARD_TAGS_LIST),upload.ram.maximum_size)

# Commands
# ----------------------------------
#
# FIRST_O_IN_LD = $$(find $(BUILDS_PATH) -name *.s.o) $$(find $(BUILDS_PATH) -name variant.cpp.o)

# Link command
#
# COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_O_IN_LD) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) -Wl,--end-group
# COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_O_IN_LD) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) -lc -Wl,--end-group -lm -lgcc -lstdc++
# COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(REMOTE_OBJS) $(LOCAL_OBJS) -lc -Wl,--end-group -lm -lgcc -lstdc++
## COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_O_IN_LD) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) -lc -Wl,--end-group -lm -lgcc -lstdc++
COMMAND_LINK = $(CC) $(FLAGS_LD) $(OUT_PREPOSITION)$@ -Wl,--start-group $(FIRST_OBJS_IN_LINK) $(LOCAL_OBJS) $(LOCAL_ARCHIVES) $(USER_ARCHIVES) $(INCLUDE_A) $(TARGET_A) $(TARGET_CORE_A) -lc -Wl,--end-group -lm -lgcc -lstdc++

#$(FLAGS_LD_2)

# Upload command
#
# COMMAND_UPLOAD = $(UPLOADER_EXEC) $(UPLOADER_PORT) $(UPLOADER_OPTS) $(TARGET_BIN)

endif # BOARD_CHECK

endif # MAKEFILE_NAME

